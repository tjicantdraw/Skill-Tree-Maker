<!DOCTYPE html>
<html>
  <head>
    <title>Skill Tree Maker - Drag and Drop Online Editor</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Instantly create your own skill trees, talent trees, and ability trees with this free online skill tree maker. Includes a drag and drop skill tree maker and a fantasy skills generator. Can be used as a skill tree maker for D&D, Pathfinder, and other RPGs."
    />
    <meta
      name="keywords"
      content="skill tree maker, RPG, skill tree, game design, skill tree generator, game development, RPG maker, character development, unique rpg classes, skill generator, skill tree maker online, rpg skill tree creator, rpg skill tree maker, dnd skill tree maker"
    />

    <meta name="robots" content="index, follow" />
    <meta name="author" content="RPG Skill Tree Generator" />

    <meta property="og:site_name" content="Skill Tree Maker" />

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png" />
    <link rel="manifest" href="/icons/site.webmanifest" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Skill Tree Maker - Drag and Drop Online Editor",
        "image": {
          "@type": "ImageObject",
          "url": "https://www.rpgskilltreegenerator.com/img/examples/rpg skill tree maker open source easy.png",
          "width": 1200,
          "height": 630,
          "caption": "Skill Tree Maker - Create a custom skill tree for your RPG character or game"
        },
        "url": "https://www.rpgskilltreegenerator.com/",
        "description": "Instantly customize your own skill trees, talent trees, and ability trees with this free online skill tree maker. Type a class idea, like Holy Necromancer or Garlic Knight, and get an RPG skill tree with JSON export.",
        "applicationCategory": "Game Design Tool",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "screenshot": [
          {
            "@type": "ImageObject",
            "url": "https://www.rpgskilltreegenerator.com/img/examples/holy necromancer skill tree.png",
            "caption": "Holy Necromancer Skill Tree Example"
          },
          {
            "@type": "ImageObject",
            "url": "https://www.rpgskilltreegenerator.com/img/examples/sock wizard skill tree.png",
            "caption": "Sock Wizard Skill Tree Example"
          }
        ],
        "potentialAction": {
          "@type": "CreateAction",
          "target": "https://www.rpgskilltreegenerator.com/",
          "description": "Create a custom skill tree for your RPG character or game",
          "name": "Create Skill Tree"
        }
      }
    </script>

    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "RPG Skill Tree Maker",
        "alternateName": ["Skill Tree Maker"],
        "url": "https://www.rpgskilltreegenerator.com/"
      }
    </script>

    <!-- Open Graph Meta Tags (for social media) -->
    <meta property="og:title" content="RPG Skill Tree Maker" />
    <meta name="twitter:title" content="RPG Skill Tree Maker" />
    <meta
      property="og:description"
      content="Skill Tree Maker - Talent, Class, and Ability Tree Generator and Editor."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.rpgskilltreegenerator.com/" />
    <meta
      property="og:image"
      content="https://www.rpgskilltreegenerator.com/img/examples/rpg skill tree maker open source easy.png"
    />

    <meta
      property="og:image"
      content="https://www.rpgskilltreegenerator.com/img/examples/holy necromancer skill tree.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="Holy Necromancer Skill Tree Example" />

    <meta
      property="og:image"
      content="https://www.rpgskilltreegenerator.com/img/examples/sock wizard skill tree.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="Sock Wizard Skill Tree Example" />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="RPG Skill Tree Designer" />
    <meta
      name="twitter:description"
      content="Talent, Class, and Ability Tree Generator and Editor."
    />
    <meta
      name="twitter:image"
      content="https://www.rpgskilltreegenerator.com/img/examples/rpg skill tree maker open source easy.png"
    />

    <style>
      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: black;
        opacity: 1;
        z-index: 9999;
        filter: blur(5px);
        transition: opacity 1.5s ease, filter 1.5s ease;
      }

      #overlay.fade-out {
        opacity: 0;
        filter: blur(0px);
        pointer-events: none;
      }
    </style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = 'https://mmkuojxexptlgosaepop.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ta3VvanhleHB0bGdvc2FlcG9wIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIxMjQ4MDgsImV4cCI6MjA4NzcwMDgwOH0.DLFsKfbnq7Zvo4hAdg1UPz3qZP_NZK4d6PafyRtGl7o';
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>
    <script src="/lib/vue.global.js"></script>
    <!-- <script src="/lib/vue.global.prod.min.js"></script> -->
    <style>
      body {
        background: #000000;
        padding: 0;
        margin: 0;
      }

      .talent-tree {
        background: linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)),
          url("/img/background/grass-ancient.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        height: calc(100vh);
        user-select: none;
        /* Prevent text selection during panning */
        position: relative;
        overflow: hidden;
        /* padding: 20px; */
        opacity: 0;
        filter: blur(10px);
        transition: opacity 0.5s ease, filter 0.5s ease, background-image 0.5s ease;
        touch-action: none;
        /* Prevents browser handling of touch events */
        -webkit-touch-callout: none;
        /* Prevents iOS callout on long press */
        -webkit-user-select: none;
        /* Prevents text selection on iOS */
      }

      .talent-tree.loaded {
        opacity: 1;
        filter: blur(0);
      }

      .skill {
        position: absolute;
        width: 60px;
        height: 60px;
        background: #2a2a2a;
        border: 2px solid #292929;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        /* transition: all 0.3s ease; */
        transform: translate3d(0, 0, 0);
        will-change: transform;
        z-index: 1;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
        /* Removes tap highlight on iOS */

        backface-visibility: hidden; /* Reduce painting */
        perspective: 1000; /* Create stacking context for better performance */
      }

      :root {
        --tree-unlock-color: #ffd700;
      }

      .skill:hover img {
        filter: brightness(1.7);
        /* box-shadow: 0 0 15px rgb(189, 122, 0); */
        box-shadow: 0 0 15px var(--tree-unlock-color);
      }

      /* Add touch device styles */

      .skill:focus img,
      .skill:active img {
        filter: brightness(1.7);
        box-shadow: 0 0 15px rgb(189, 122, 0);
      }

      .square-skills .skill,
      .square-skills .skill img,
      .square-skills .skill-preview,
      .square-skills .skill-preview img,
      .square-skills .image-option {
        border-radius: 0px !important;
      }

      .diamond-skills .skill,
      .diamond-skills .skill img,
      .diamond-skills .skill-preview,
      .diamond-skills .skill-preview img,
      .diamond-skills .image-option {
        border-radius: 4px;
        transform: rotate(45deg) !important;
      }

      /* Add this to keep the skill content straight */
      .diamond-skills .skill img,
      .diamond-skills .skill-preview img {
        /* transform: rotate(-45deg); */
      }

      .diamond-skills .skill .skill-points {
        transform: rotate(-45deg) !important;
        bottom: -25px;
        left: 90%;
      }

      .diamond-skills .skill-tooltip {
        transform: rotate(-45deg) !important;
      }

      .hexagon-skills .skill {
        clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        border-radius: 0px !important;
      }
      .hexagon-skills .skill img {
        clip-path: polygon(
          50% 1px,
          calc(100% - 5px) 25%,
          calc(100% - 5px) 75%,
          50% calc(100% - 5px),
          5px 75%,
          5px 25%
        ) !important;
        border-radius: 0;
      }

      .skill-actions {
        position: absolute;
        display: flex;
        gap: 10px;
        top: -40px;
        left: 50%;

        transform: translateX(-50%);
        z-index: 2;
      }

      .action-btn {
        background: #3498db;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        color: white;
        background: rgba(26, 26, 26, 0.95);
        padding: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        position: relative;
        touch-action: manipulation;
        /* Optimize for touch */
        -webkit-tap-highlight-color: transparent;
      }

      .action-btn-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        white-space: nowrap;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 5px;
        z-index: 9998;
      }

      .connection {
        position: absolute;
        background: #3498db;
        height: 10px;
        transform-origin: left center;
        background: #4a4a4a;
        /* More subtle connection line */
        box-shadow: 0 0 5px rgba(74, 74, 74, 0.5);
        transition: background 0.25s ease;
        will-change: transform;
      }

      .connection-after {
        content: "";
        position: absolute;
        /* right: 31px; */
        right: 2px;
        /* This makes arrow slide up and down */
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid #4a4a4a;
        /* Increased to 20px for larger arrow */
        border-top: 5px solid transparent;
        /* Increased to 10px for proportional width */
        border-bottom: 5px solid transparent;
        /* Increased to 10px for proportional width */
        transition: border-left-color 0.25s ease;
        will-change: transform;
      }

      .connection.active .connection-after {
        border-left-color: var(--tree-unlock-color);
        /* #ffd700; */
      }

      .connection.connection-hover .connection-after {
        border-left-color: #ff4747;
      }

      .view-mode .connection.connection-hover {
        background: #4a4a4a;
        box-shadow: none;
      }

      .view-mode .connection.connection-hover .connection-after {
        border-left-color: #4a4a4a;
      }

      .view-mode .connection-hitbox {
        cursor: default;
      }

      .connection.active {
        background: var(--tree-unlock-color);
        /* #ffd700; */
        /* Golden/yellow color for active connections */
        box-shadow: 0 0 5px rgba(var(--tree-unlock-color), 0.9);
        /* rgba(255, 215, 0, 0.9); */
      }

      .connection.dotted {
        background: repeating-linear-gradient(
          to right,
          #4a4a4a 0,
          #4a4a4a 8px,
          transparent 8px,
          transparent 16px
        );
      }

      .connection.dotted.active {
        background: repeating-linear-gradient(
          to right,
          #ffd700 0,
          #ffd700 8px,
          transparent 8px,
          transparent 16px
        );
      }

      .connection.dotted.connection-hover {
        background: repeating-linear-gradient(
          to right,
          #ff4747 0,
          #ff4747 8px,
          transparent 8px,
          transparent 16px
        );
      }

      /* Connection Menu */

      .skill-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.95);
        color: #ffd100;
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
        width: 320px;
        pointer-events: auto;
        z-index: 1000;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        font-family: Verdana, sans-serif;
        border: 1px solid #4a4a4a;
        transform: translateZ(0);
        will-change: transform;
        cursor: text;
      }
      .skill-tooltip,
      .skill-tooltip * {
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      .skill-tooltip.tooltip-left {
        right: calc(100% + 10px);
        top: calc(50% + 23px);
        transform: translateY(-50%);
      }

      .skill-tooltip.tooltip-right {
        left: calc(100% + 10px);
        top: calc(50% + 23px);
        transform: translateY(-50%);
      }

      .skill-tooltip .skill-requirements {
        color: #ff4747 !important;
        /* margin: 5px 0 10px 0; */
        /* padding: 8px; */
        /* background: rgba(139, 69, 19, 0.3); */
        /* border: 1px solid #8B4513; */
        /* border-radius: 3px; */
      }

      .skill-tooltip .requirement-item {
        color: #ff6b6b !important;
        font-size: 12px;
        font-weight: normal;
        margin: 2px 0;
        line-height: 1.3;
      }

      /* Add this media query for mobile devices */
      @media (max-width: 768px) {
        .skill-tooltip {
          width: 200px;
          font-size: 12px;
          top: calc(50% + 43px) !important;
        }

        /* .skill-tooltip .damage {
        color: #ff4747;
        font-weight: normal;
        margin-top: 8px;
      } */

        /* Add mobile styles for skills */
        .skill {
          width: 45px;
          /* Smaller skill icons on mobile */
          height: 45px;
          margin-left: 5px;
          margin-top: 5px;
        }

        /* Adjust class title for mobile */
        .class-title {
          font-size: 1rem !important;
          /* bottom: 10px; */
          bottom: 57px !important;
          width: 60%;
          width: 40vw;
          /* white-space: nowrap; */
          /* overflow: hidden; */
          /* text-overflow: ellipsis; */
        }

        /* Adjust generate controls for mobile */
        .generate-controls {
          width: 80%;
          /* Reduced from 90% */
          padding: 8px;
          /* Reduced from 15px */
          gap: 5px;
          /* Reduced from 10px */
          flex-direction: column;
          /* Stack input above buttons */
        }

        .generate-input {
          width: calc(100% - 18px);
          padding: 8px;
          font-size: 14px;
        }

        /* Add a container div for buttons */
        .button-container {
          display: flex;
          width: 100%;
          gap: 5px;
        }

        .generate-btn {
          width: 80%;
          /* Take up 80% of the space */
          padding: 8px;
          font-size: 14px;
          top: 0px !important;
        }

        .random-generate-btn {
          width: 20%;
          /* Take up 20% of the space */
          padding: 8px;
          font-size: 14px;
          margin-top: 0px !important;
        }

        .skill-preview-container {
          flex: 0 0 30px !important;
          /* Fixed width for preview section */
        }

        .skill-preview::after {
          content: "Tap to change image";
          /* Change text for mobile */
          top: -35px;
          /* Adjust position for mobile */
          font-size: 11px;
          /* Smaller font size for mobile */
          padding: 3px 8px;
          /* Smaller padding for mobile */
        }

        /* Show tooltip briefly on mobile tap */
        .skill-preview::after {
          opacity: 1 !important;
          background-color: #00000000;
        }
      }

      .skill-tooltip h3 {
        margin: 0 0 5px 0;
        color: #ffffff;
        /* White title */
        font-size: 15px;
        font-weight: bold;
        border-bottom: 1px solid #4a4a4a;
        padding-bottom: 5px;
      }

      .skill-tooltip p {
        margin: 5px 0;
        font-size: 12px;
        color: #ffd100;
        /* Description in golden yellow */
        line-height: 1.4;
      }

      .skill-tooltip .damage {
        color: #ff4747;
        /* Brighter red for damage */
        font-weight: normal;
        margin-top: 8px;
      }

      .skill-points {
        position: absolute;
        bottom: -22px;
        left: 50%;
        font-family: Verdana, sans-serif;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 12px;
        white-space: nowrap;
      }

      .skill img {
        filter: brightness(1);
        transition: all 0.2s ease;

        transform: translate3d(0, 0, 0);
        will-change: transform;
        backface-visibility: hidden;
      }

      .skill.inactive img {
        filter: grayscale(100%) brightness(0.9);
      }
      .skill.unlockable img {
        filter: brightness(0.9); /* Slightly dimmed but colored */
      }

      .options-button {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        z-index: 1000;
      }

      .options-panel {
        position: fixed;
        bottom: 70px;
        left: 20px;
        background: rgba(26, 26, 26, 0.95);
        padding: 15px;
        border-radius: 8px;
        color: white;
        z-index: 1000;
        font-family: Verdana, sans-serif;
        margin-right: 20px;

        animation: panelFadeIn 0.3s ease forwards;
        font-size: 14px;
      }

      /* Add keyframes for fade in/out */
      @keyframes panelFadeIn {
        from {
          opacity: 0;
          transform: scale(0.95) translateY(10px);
        }

        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .options-panel label {
        display: block;
        margin-bottom: 5px;
      }

      .options-panel input {
        width: 100px;
        margin-bottom: 10px;
      }

      .options-panel label {
        display: block;
        margin-bottom: 5px;
        color: #ffd100;
        /* Added golden color to match theme */
      }

      .options-panel input {
        width: 200px;
        /* Increased width for better visibility */
        margin-bottom: 10px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        color: #ffffff;
        font-family: Verdana, sans-serif;
      }

      .options-panel input:focus {
        outline: none;
        border-color: #ffd100;
      }

      @keyframes skillIntro {
        0% {
          opacity: 0;
          transform: scale(0.3) translateY(20px);
        }

        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .skill {
        /* ... existing skill styles ... */
        opacity: 1;
        transform: scale(1);
      }

      .skill.animate-in {
        animation: skillIntro 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.28) forwards;
      }

      .skill.skilled {
        border: 2px solid var(--tree-unlock-color);
        /* #ffd700; */
        box-shadow: 0 0 10px rgba(var(--tree-unlock-color), 0.9);
        /* rgba(255, 215, 0, 0.9); */
      }

      .btn {
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
      }

      .btn {
        /* background: #3498db; */
        background: rgba(74, 74, 74, 0.7);
        color: #ffd100;
        /* color: white; */
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
      }

      .btn:hover {
        background: #2980b9;
      }

      .edit-modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }

      .edit-modal {
        display: flex;
        /* Add this */
        gap: 20px;
        /* Add this */
        background: rgba(16, 16, 16, 0.95);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        width: 90%;
        /* max-width: 679px; */
        /* Increased from 500px to accommodate preview */
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        color: #ffd100;
        font-family: Verdana, sans-serif;
        margin-left: 7%;
        margin-right: 7%;
      }

      .edit-modal::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: red;
      }

      /* Add new styles for the preview section */
      .skill-preview-container {
        flex: 0 0 100px;
        /* Fixed width for preview section */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .skill-preview {
        width: 60px;
        height: 60px;
        /* background: #2a2a2a; */
        background-color: rgb(21, 21, 21);
        border: 2px solid #292929;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        top: 44px;
        position: relative;
        margin-left: 5px;
      }

      .skill-preview::after {
        content: "Click to swap image";
        position: absolute;
        bottom: -45px;
        /* Position below the skill points counter */
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #ffd100;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .skill-preview:hover::after {
        opacity: 1;
      }

      .skill-preview.skilled {
        border: 2px solid #ffd700;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.9);
      }

      .skill-preview img {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        object-fit: cover;
      }

      .skill-preview .skill-points {
        position: absolute;
        bottom: -22px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 12px;
        white-space: nowrap;
      }

      .edit-form-container {
        flex: 1;
        /* Take remaining space */
      }

      .edit-modal h2 {
        color: #ffffff;
        text-align: center;
        margin: 0 0 20px 0;
        padding-bottom: 10px;
        border-bottom: 1px solid #4a4a4a;
        font-size: 18px;
      }

      .edit-field {
        margin-bottom: 15px;
      }

      .edit-field label {
        display: block;
        margin-bottom: 5px;
        color: #ffd100;
        font-size: 14px;
      }

      .edit-field input,
      .edit-field textarea {
        width: 100%;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        color: #ffffff;
        font-family: Verdana, sans-serif;
        font-size: 14px;
        transition: border-color 0.2s ease;
      }

      .edit-field textarea {
        height: 100px;
        resize: vertical;
      }

      .edit-field input:focus,
      .edit-field textarea:focus {
        outline: none;
        border-color: #ffd100;
      }

      .edit-modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }

      .edit-modal-button {
        padding: 8px 20px;
        border: none;
        border-radius: 4px;
        font-family: Verdana, sans-serif;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .save-button {
        background: #4a4a4a;
        color: #ffd100;
      }

      .save-button:hover {
        background: #5a5a5a;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .cancel-button {
        background: #2a2a2a;
        color: #ffffff;
      }

      .cancel-button:hover {
        background: #3a3a3a;
      }

      .skill:hover {
        z-index: 100;
      }

      .random-btn {
        background: #2ecc71;
        /* Green color */
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        transition: background-color 0.2s ease;
      }

      .random-btn:hover {
        background: #27ae60;
        /* Darker green on hover */
      }

      .skill:hover .skill-tooltip {
        z-index: 1000;
      }

      .skill.active img {
        filter: brightness(1.7);
        box-shadow: 0 0 15px rgb(189, 122, 0);
      }

      .class-title {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffd100;
        font-family: Verdana, sans-serif;
        font-size: 24px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 1;
        padding: 10px 20px;
        border-radius: 8px;
        pointer-events: none;
        font-family: "Rocher", serif;
        opacity: 0;
        animation: slideUp 0.5s ease 1s forwards;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }

        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      /* FONT */
      @font-face {
        font-family: "Rocher";
        src: url("/css/RocherColorGX.woff2");
      }

      .generate-controls {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        display: flex;
        gap: 10px;
        align-items: center;
        background: rgba(26, 26, 26, 0.95);
        padding: 15px;
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        border: 1px solid #4a4a4a;
        animation: slideDown 0.5s ease 1s both;
      }

      .generate-controls.hidden {
        opacity: 0 !important;
        pointer-events: none;
      }

      .generate-controls .close-btn-generate {
        position: absolute;
        top: -10px;
        right: -10px;
        background: none;
        border: none;
        color: #ffd100;
        cursor: pointer;
        font-size: 18px;
        padding: 5px;
        /* z-index: 2; */
        border-radius: 50%;
        width: 30px;
        height: 30px;
        color: white;
        background: rgba(26, 26, 26, 0.95);
        padding: 8px;
        align-items: center;
        justify-content: center;
        font-size: 14px;
      }

      .generate-controls .close-btn-generate:focus {
        outline: none;
        box-shadow: none;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }

        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .generate-input {
        flex: 1;
        padding: 12px;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.7);
        color: #ffd100;
        font-family: "Rocher", serif;
        font-size: 16px;
      }

      .generate-input:focus {
        outline: none;
        border-color: #ffd100;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .generate-btn {
        background: #4a4a4a;
        color: #ffd100;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        cursor: pointer;
        white-space: nowrap;
        font-family: "Rocher", serif;
        font-size: 16px;
        transition: all 0.2s ease;
        top: -4px;
      }

      .generate-btn:hover {
        background: #5a5a5a;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .generate-btn:disabled {
        background: #2a2a2a;
        color: #666;
        cursor: not-allowed;
        box-shadow: none;
      }

      .history-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        z-index: 1000;
      }

      .history-btn {
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .history-btn:hover {
        opacity: 1;
      }

      .history-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      @media (max-width: 768px) {
        .generate-controls {
          width: 80%;
          /* Reduced from 90% */
          padding: 8px;
          /* Reduced from 15px */
          gap: 5px;
          /* Reduced from 10px */
          flex-direction: column;
          /* Stack input above buttons */
        }

        .generate-input {
          width: calc(100% - 18px);
          padding: 8px;
          font-size: 14px;
        }

        /* Add a container div for buttons */
        .button-container {
          display: flex;
          width: 100%;
          gap: 5px;
        }

        .generate-btn {
          width: 80%;
          /* Take up 80% of the space */
          padding: 8px;
          font-size: 14px;
          top: 0px;
        }

        .random-generate-btn {
          width: 20%;
          /* Take up 20% of the space */
          padding: 8px;
          font-size: 14px;
          margin-top: 0px;
          margin-left: 0px !important;
        }
      }

      .random-generate-btn {
        background: rgba(74, 74, 74, 0.7);
        color: #ffd100;
        border: none;
        padding: 12px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-family: "Rocher", serif;
        font-size: 20px;
        transition: all 0.2s ease;
        opacity: 0.8;
        margin-left: 8px;
        margin-top: 3px;
      }

      .random-generate-btn:hover {
        background: rgba(90, 90, 90, 0.8);
        opacity: 1;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.2);
      }

      .random-generate-btn:disabled {
        background: #2a2a2a;
        color: #666;
        cursor: not-allowed;
        box-shadow: none;
        opacity: 0.5;
      }

      /* Update generate-controls to accommodate the new button */
      .generate-controls {
        gap: 8px;
        /* Reduced from 10px to tighten spacing */
      }

      /* Ensure mobile responsiveness */
      @media (max-width: 768px) {
        .random-generate-btn {
          padding: 8px 12px;
          font-size: 16px;
        }
      }

      .generate-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        white-space: nowrap;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 5px;
        z-index: 9998;
      }

      .image-selector-modal {
        position: fixed;
        top: 50%;
        left: 43%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(16, 16, 16, 0.98);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        width: 80%;
        margin-left: 7%;
        margin-right: 7%;
        max-width: 679px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 11000;
        opacity: 0;
        transition: all 0.3s ease;
        min-height: 350px;
      }

      .image-selector-modal.active {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 15px;
        padding: 15px;
      }

      .image-option {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 2px solid #292929;
        cursor: pointer;
        transition: all 0.2s ease;
        -webkit-tap-highlight-color: transparent;
        margin-bottom: 15px;
      }

      .image-option:hover {
        border-color: #ffd700;
        transform: scale(1.1);
      }

      .image-option.selected {
        border-color: #ffd700;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      }

      .image-selector-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }

      .generate-input {
        position: relative;
      }

      .generate-btn,
      .random-generate-btn {
        position: relative;
      }

      .edit-field {
        margin-bottom: 15px;
      }

      .edit-field.row {
        display: flex;
        gap: 10px;
        justify-content: space-between;
      }

      .edit-field.row > div {
        flex: 1;
        min-width: 0;
        /* Prevents flex items from overflowing */
      }

      .edit-field input,
      .edit-field textarea {
        width: calc(100% - 24px);
        /* Adjust for padding */
        box-sizing: border-box;
        /* Include padding in width calculation */
      }

      .edit-field.row input {
        width: 100%;
        /* Full width within its container */
      }

      /* Add or update these styles */
      @media (max-width: 768px) {
        .edit-modal h2 {
          font-size: 16px;
          /* Smaller title on mobile */
          margin: 0 0 15px 0;
        }

        .edit-field label {
          font-size: 12px;
        }
        .option-edit-label {
          font-size: 12px !important;
        }
        .option-group-select {
          font-size: 9px !important;
        }

        .edit-field input,
        .edit-field textarea {
          font-size: 12px;
          /* Smaller input text */
          padding: 6px 10px;
          /* Slightly smaller padding */
        }

        .skill-preview-container {
          margin-top: 20px;
          /* Move preview down on mobile */
        }

        .edit-modal-button {
          font-size: 12px;
          /* Smaller button text */
          padding: 6px 16px;
          /* Slightly smaller padding */
        }
      }

      .edit-field.row {
        display: flex;
        gap: 10px;
        justify-content: space-between;
      }

      .edit-field.row > div {
        flex: 1;
        min-width: 0;
        /* Prevents flex items from overflowing */
        display: flex;
        /* Add this */
        flex-direction: column;
        /* Add this */
        align-items: flex-start;
        /* Add this */
      }

      .edit-field.row label {
        margin-bottom: 5px;
        /* Add consistent spacing below labels */
        min-height: 1.2em;
        /* Add this to ensure consistent height */
        width: 100%;
        /* Add this to ensure full width */
        position: relative;
        /* Add this one line */
      }

      .edit-field.row input {
        width: 100%;
        margin-top: auto;
        /* Add this to push inputs to bottom */
      }

      .skill-preview {
        position: relative;
        /* Add this */
      }

      .skill-preview::after {
        content: "Tap to Swap";
        position: absolute;
        top: -35px;
        /* Position below the skill points counter */
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0);
        color: #ffd100;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
        /* animation: slideDown 0.5s ease 1s both; */
      }

      .skill-preview:hover::after {
        opacity: 1;
      }

      .skill-preview.hide-tooltip::after {
        display: none;
      }

      .share-btn {
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        transition: background-color 0.2s ease;
      }

      .share-btn:hover {
        background: #2980b9;
      }

      .share-btn .action-btn-tooltip {
        margin-left: 50px;
      }

      .share-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(16, 16, 16, 0.98);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        z-index: 10001;
        color: #ffd100;
        text-align: center;
        font-family: "Rocher", serif;
        width: 70%;
      }

      /* Add new styles for the close button */
      .share-modal .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        color: #ffd100;
        cursor: pointer;
        font-size: 18px;
        padding: 5px;
        opacity: 0.8;
        transition: opacity 0.2s ease;
      }

      .share-modal .close-btn:hover {
        opacity: 1;
      }

      .share-link {
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        word-break: break-all;
      }

      .copy-btn {
        background: #4a4a4a;
        color: #ffd100;
        border: none;
        padding: 8px 20px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
      }

      .copy-btn:hover {
        background: #5a5a5a;
      }

      /* Add new styles for the button container */
      @media (min-width: 768px) {
        .bottom-left-buttons {
          position: fixed;
          bottom: 20px;
          left: 20px;
          display: flex;
          gap: 10px;
          z-index: 1000;
        }

        /* Update the options-button style to match other buttons */
        .options-button,
        .share-button,
        .download-button {
          background: rgba(26, 26, 26, 0.95);
          border: none;
          border-radius: 50%;
          width: 40px;
          height: 40px;
          color: white;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
          transition: opacity 0.2s ease;
        }

        .options-button:hover,
        .share-button:hover,
        .download-button:hover {
          opacity: 0.8;
        }

        .download-button,
        .share-button,
        .discord-button {
          /* display: flex; */
          position: absolute;
          top: -39px;
        }

        .download-button {
          left: 50;
        }

        .share-button {
          left: 100px;
        }

        .discord-button {
          left: 150px;
        }
      }

      @media (max-width: 768px) {
        .download-button,
        .share-button {
          display: none !important;
        }

        .discord-button {
          left: 70px;
          bottom: 20px;
          position: fixed;
        }

        .points-display {
          /* left: 10px; */
          bottom: 60px !important;
          right: 24px !important;
          position: absolute;
        }
      }

      .image-upload-section {
        padding: 15px;
        border-bottom: 1px solid #4a4a4a;
        text-align: center;
      }

      .upload-button {
        display: inline-block;
        background: #4a4a4a;
        color: #ffd100;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .upload-button:hover {
        background: #5a5a5a;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .upload-info {
        color: #999;
        font-size: 12px;
        margin-top: 8px;
      }

      .discord-button {
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        /* padding-left: 20px; */
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: opacity 0.2s ease;
        margin-left: 0px;
        margin-top: 1px;
      }

      .discord-button img {
        /* margin-left: 10px; */
        width: 24px;
        height: 24px;
      }

      .discord-button:hover {
        opacity: 0.8;
      }

      /* Add new styles for the load button */
      .load-button {
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: opacity 0.2s ease;
        position: absolute;
        top: -37px;
        left: 300px;
        /* left: 200px; */
      }

      .load-button:hover {
        opacity: 0.8;
      }

      @media (max-width: 768px) {
        .load-button {
          display: none;
        }
      }

      /* @media (max-width: 768px) {
                  .bottom-left-buttons {
                      display: flex;
                      gap: 10px;
                  }
              } */

      #resources-container {
        max-height: 150px;
        overflow-y: auto;
      }

      #resources-container .row {
        gap: 5px;
        margin-bottom: 5px;
      }

      #resources-container button {
        background: none;
        border: none;
        color: #ff4747;
        cursor: pointer;
      }

      .add-resource {
        background: rgba(0, 0, 0, 0);
        color: #ffd100;
        color: #777;
        border: none;
        padding: 5px;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
        margin-top: 5px;
      }

      .skill-tooltip .resources-container {
        display: flex;
        flex-direction: column;
        gap: 3px;
        margin: 0px 0;
        /* border-top: 1px solid #4a4a4a; */
        /* padding-top: 5px; */
      }

      .skill-tooltip .resource-row {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
      }

      /* Add hover state */
      .connection.connection-hover {
        background: #ff4747;
        /* Red color on hover to indicate deletion */
        box-shadow: 0 0 8px rgba(255, 71, 71, 0.7);
      }

      /* Invisible wider hit area */
      .connection-hitbox {
        position: absolute;
        top: -8px;
        /* Extend 8px above */
        bottom: -8px;
        /* Extend 8px below */
        left: 0;
        right: 0;
        cursor: pointer;
      }

      .edit-resource-row {
        cursor: move;
        /* padding: 4px; */
        user-select: none;
      }

      .edit-resource-row:active {
        opacity: 0.8;
        background: rgba(74, 74, 74, 0.4);
      }

      .grid-overlay {
        /* position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0; */
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
      }

      .grid-line {
        position: absolute;
        background-color: rgba(255, 255, 255, var(--grid-opacity));
        will-change: transform;
      }

      .grid-line.horizontal {
        width: 100%;
        height: 1px; /*increase to 2px to avoid missing lines when zooming out   */
      }

      .grid-line.vertical {
        height: 100%;
        width: 1px;
      }

      .points-display {
        position: fixed;
        bottom: 20px;
        right: 125px;
        /* Position before undo/redo buttons */
        /* background: rgba(26, 26, 26, 0.95); */
        color: #ffd100;
        padding: 8px 15px;
        border-radius: 4px;
        font-family: "Rocher", serif;
        z-index: 1000;
        border: 1px solid #4a4a4a;
      }

      @media (max-width: 768px) {
        .points-display {
          font-size: 12px;
          padding: 6px 10px;
          right: 123px;
          bottom: 24px;
        }
      }

      .toast-notification {
        position: fixed;
        bottom: 70px;
        /* left: 50%; */
        right: 20px;
        transform: translateX(0%) translateY(50%);
        background: rgba(26, 26, 26, 0.95);
        color: #ffd100;
        padding: 12px 24px;
        border-radius: 8px;
        font-family: "Rocher", serif;
        z-index: 10000;
        border: 1px solid #4a4a4a;
        opacity: 0;
        transition: all 0.3s ease;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .toast-notification.show {
        transform: translateX(0%) translateY(0%);
        opacity: 1;
      }

      .range-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 10px 0;
      }

      input[type="range"] {
        /* -webkit-appearance: none; */
        width: 100px;
        /* height: 2px; */
        /* background: rgba(255, 209, 0, 0.2); */
        /* border-radius: 2px; */
      }

      /*
      input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          width: 12px;
          height: 12px;
          background: #ffd100;
          border-radius: 50%;
          cursor: pointer;
          transition: transform 0.2s;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
          transform: scale(1.2);
      } */

      .options-panel {
        position: fixed;
        bottom: 70px;
        left: 20px;
        background: rgba(26, 26, 26, 0.95);
        padding: 20px;
        border-radius: 8px;
        color: white;
        z-index: 1000;
        font-family: Verdana, sans-serif;
        margin-right: 20px;
        animation: panelFadeIn 0.3s ease forwards;
        font-size: 14px;
        max-height: 75vh;
        overflow-y: auto;
        border: 1px solid #4a4a4a;
        /* min-width: 280px; */
        width: 370px;
      }

      .options-section {
        /* border: 1px solid #4a4a4a; */
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
        background: rgba(0, 0, 0, 0.2);
      }

      .options-section:last-child {
        margin-bottom: 0;
      }

      .options-section h3 {
        color: #ffd100;
        margin: 0 0 15px 0;
        font-size: 16px;
        border-bottom: 1px solid #4a4a4a;
        padding-bottom: 8px;
        font-family: Verdana, sans-serif;
        font-weight: 300;
      }

      .option-group {
        margin-bottom: 12px;
      }

      .option-group:last-child {
        margin-bottom: 0;
      }

      .option-group label {
        display: block;
        color: #ffd100;
        margin-bottom: 6px;
        font-size: 14px;
      }

      .option-group input[type="text"],
      .option-group input[type="number"] {
        width: 90%;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        /* border: 1px solid #4a4a4a; */
        border-radius: 4px;
        color: white;
      }

      .option-group select {
        width: 90%;
        padding: 8px;
        background: rgb(0, 0, 0);
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        color: white;
      }

      .color-controls,
      .range-container,
      .grid-controls,
      .snap-controls {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .color-controls input[type="color"] {
        width: 40px;
        height: 30px;
        padding: 0;
        border: 1px solid #4a4a4a;
      }

      .color-controls input[type="range"] {
        flex: 1;
      }

      .button-group {
        display: flex;
        gap: 10px;
      }

      .button-group .btn {
        flex: 1;
      }

      /* Checkbox styling */
      .option-group input[type="checkbox"] {
        margin-right: 8px;
        width: auto;
      }

      /* Range input styling */
      .option-group input[type="range"] {
        width: 100%;
        margin: 8px 0;
      }

      @media (max-width: 768px) {
        .options-panel {
          max-height: 70vh;
          /* width: 81vw; */
          width: calc(100vw - 100px);
        }
      }

      /* Update modal styles */
      .load-modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        /* background: rgba(0, 0, 0, 0.85); */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .load-modal-backdrop.active {
        opacity: 1;
      }

      .load-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(16, 16, 16, 0.98);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        z-index: 11000;
        color: #ffd100;
        text-align: center;
        font-family: "Rocher", serif;
        width: 70%;
        max-width: 400px;
        opacity: 0;
        transition: all 0.3s ease;
      }

      .load-modal.active {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      .recent-backgrounds {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }

      .background-thumbnail {
        width: 60px;
        height: 40px;
        border-radius: 4px;
        background-size: cover;
        background-position: center;
        cursor: pointer;
        border: 1px solid #4a4a4a;
        transition: all 0.2s ease;
      }

      .background-thumbnail:hover {
        border-color: #ffd100;
        transform: scale(1.05);
      }

      .selection-box {
        position: absolute;
        border: 1px solid #ffd100;
        background: rgba(255, 209, 0, 0.1);
        pointer-events: none;
        z-index: 1;
      }

      .zoom-tree {
        position: relative;
        transform: translate(-25%, -25%) scale(1);
        transform-origin: center center;
        width: 200%;
        height: 200%;

        pointer-events: none;
      }
      .zoom-tree .skill-connections-container {
        pointer-events: auto;

        /* will-change: transform; */
      }
      .rank-btn {
        background: rgba(74, 74, 74, 0.7);
        color: #ffd100;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 14px;
      }

      .rank-span {
        font-size: 14px;
        color: #ffd100;
      }

      .rank-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .rank-btn:hover:not(:disabled) {
        background: rgba(90, 90, 90, 0.8);
      }

      .info-panel {
        font-size: 12px;
        position: fixed;
        bottom: 245px;
        right: 25px;
        background: rgba(0, 0, 0, 0.65);
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #4a4a4a;
        color: white;
        z-index: 1000;
      }

      .info-btn {
        position: fixed;
        bottom: 17px;
        left: 270px;
        width: 40px;
        height: 40px;
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        color: white;
        z-index: 1000;
        cursor: pointer;
      }
      .twitter-btn {
        position: fixed;
        bottom: 17px;
        left: 220px;
        width: 40px;
        height: 40px;
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        color: white;
        z-index: 1000;
        cursor: pointer;
      }
      .twitter-btn .inner-button {
        width: 100%;
        height: 100%;
        background-image: url("https://static.vecteezy.com/system/resources/previews/027/127/500/non_2x/patreon-logo-patreon-icon-transparent-free-png.png");
        background-size: cover;
        background-position: center;
      }
      @media (max-width: 768px) {
        .twitter-btn {
          bottom: 20px;
          left: 120px;
        }
        .info-btn {
          bottom: 20px;
          left: 168px;
        }
      }
      .stats-panel {
        font-size: 12px;
        position: fixed;
        bottom: 128px;
        right: 25px;
        background: rgba(0, 0, 0, 0.65);
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        padding: 20px;
        border-radius: 4px;
        border: 1px solid #4a4a4a;
        color: white;
        z-index: 1000;
        width: 137px;
      }

      .stats-panel h3 {
        /* color: #ffd100; */
        margin: 0 0 15px 0;
        font-size: 16px;
        border-bottom: 1px solid #4a4a4a;
        padding-bottom: 8px;
      }

      .upload-row {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 10px;
      }

      .url-input {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #4a4a4a;
        color: #ffffff;
        font-family: Verdana, sans-serif;
        font-size: 14px;
        border-radius: 4px;
        width: calc(100% - 24px);
        padding: 8px 12px;
        transition: border-color 0.2s ease;
      }

      .url-input:focus {
        outline: none;
        border-color: #ffd100;
      }

      @media (min-width: 768px) {
        .url-upload {
          /* display: flex; */
          /* align-items: center; */
          height: 131px;

          /* gap: 5px; */
        }
        .image-upload-column {
          height: 131px;
        }
        .url-input {
          margin-top: 9px;
        }
      }

      @media (max-width: 768px) {
        #imageUpload2,
        #urlUpload {
          font-size: 12px;
        }
      }
      .image-selector-modal h2 {
        color: #ffffff;
        text-align: center;
        margin: 0 0 20px 0;
        padding-bottom: 10px;
        border-bottom: 1px solid #4a4a4a;
        font-size: 18px;
      }
      @media (max-width: 768px) {
        .edit-modal h2 {
          font-size: 16px;
          /* Smaller title on mobile */
          margin: 0 0 15px 0;
        }
      }

      .image-selector-modal {
        /* display: flex;
        gap: 20px;
        background: rgba(16, 16, 16, 0.95);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        width: 90%;
        max-width: 679px; */
        /* Increased from 500px to accommodate preview */
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        color: #ffd100;
        font-family: Verdana, sans-serif;
        margin-left: 7%;
        margin-right: 7%;
      }
      .remove-image-btn {
        transition: transform 0.15s cubic-bezier(0.4, 1.3, 0.6, 1);
      }
      .remove-image-btn:hover {
        transform: scale(1.5);
        z-index: 10;
      }
      .skill-name {
        position: absolute;
        top: -25px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: #ffd100;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        font-family: "Rocher", serif;
      }

      .skill-appearance-controls {
        margin-top: 70px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        /* width: 150px; */
        width: 96px;
      }

      @media (max-width: 768px) {
        .skill-appearance-controls {
          width: 75px;
        }
      }

      .skill-appearance-controls .control-group {
        margin-bottom: 10px;
      }

      .skill-appearance-controls .control-group label {
        display: block;
        margin-bottom: 5px;
        /* color: #ccc; */
        color: #ffd100;
        font-size: 14px;
      }
      @media (max-width: 768px) {
        .skill-appearance-controls .control-group label {
          font-size: 12px;
        }
      }

      .skill-appearance-controls .radio-group {
        /* display: flex; */
        /* gap: 15px; */
      }

      .skill-appearance-controls .radio-group label {
        /* display: flex; */
        align-items: center;
        gap: 5px;
        cursor: pointer;
        display: inline-block;
      }

      .skill-appearance-controls input[type="range"] {
        /* width: 100%; */
        width: calc(100% - 50px);
        /* margin: 5px 0; */
      }

      .skill-appearance-controls .radio-group span {
        font-size: 14px;
        position: relative;
        top: -7px;
        left: 6px;
      }
      @media (max-width: 768px) {
        .skill-appearance-controls .radio-group span {
          font-size: 12px;
        }
      }
      .control-point {
        position: absolute;
        width: 12px;
        height: 12px;
        background: #4caf50;
        border: 2px solid white;
        border-radius: 50%;
        cursor: move;
        z-index: 500;
        transform: translate(-50%, -50%);
      }

      .control-point:hover {
        background: #66bb6a;
        box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
      }
    </style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GBBGRRLHZC"></script>
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6633346106464623"
      crossorigin="anonymous"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-GBBGRRLHZC");
    </script>

    <script type="text/javascript">
      (function (c, l, a, r, i, t, y) {
        c[a] =
          c[a] ||
          function () {
            (c[a].q = c[a].q || []).push(arguments);
          };
        t = l.createElement(r);
        t.async = 1;
        t.src = "https://www.clarity.ms/tag/" + i;
        y = l.getElementsByTagName(r)[0];
        y.parentNode.insertBefore(t, y);
      })(window, document, "clarity", "script", "pezds8guu2");
    </script>
  </head>

  <body>
    <!-- <div id="overlay"></div> -->
    <div id="app">
      <div class="generate-controls" :class="{ hidden: !showGenerateControls }">
        <button class="close-btn-generate" @click="toggleGenerateControls"></button>
        <input
          type="text"
          v-model="inputText"
          placeholder="Enter a class idea..."
          class="generate-input"
          @keyup.enter="handleEnterKey"
          @mouseenter="showGenerateTooltip($event, 'Type a class idea like \'Holy Necromancer\' or \'Garlic Knight\'')"
          @mouseleave="hideGenerateTooltip($event)"
        />
        <div class="button-container">
          <button
            class="generate-btn"
            @click="generateTreeFromPrompt"
            :disabled="isLoading"
            @mouseenter="showGenerateTooltip($event, 'Generate a new skill tree based on your prompt. You can also type instructions.')"
            @mouseleave="hideGenerateTooltip($event)"
          >
            {{ isLoading ? 'Generating...' : 'Generate Skills' }}
          </button>
          <button
            class="random-generate-btn"
            @click="generateRandomTree"
            :disabled="isLoading"
            @mouseenter="showGenerateTooltip($event, 'Try a Random Example')"
            @mouseleave="hideGenerateTooltip($event)"
          >
            
          </button>
        </div>
      </div>
      <div
        class="talent-tree"
        @click="handleClick"
        @mousedown="startPan"
        @wheel="handleZoom"
        @touchstart="handleTreeTouchStart"
        @touchmove.prevent="handleTreeTouchMove"
        @touchend="handleTreeTouchEnd"
        @touchcancel="handleTreeTouchEnd"
        @contextmenu.prevent
      >
        <div class="zoom-tree">
          <div v-show="showGlobalGrid" class="grid-overlay" :style="gridStyle">
            <!-- Grid lines will be added dynamically -->
            <div
              v-for="line in gridLines"
              :key="line.id"
              class="grid-line"
              :class="line.type"
              :style="line.style"
            ></div>
          </div>
          <div
            v-if="this.selectionBox"
            class="selection-box"
            :style="{
                left: `${Math.min(selectionBox.x, selectionBox.x + selectionBox.width)}px`,
                top: `${Math.min(selectionBox.y, selectionBox.y + selectionBox.height)}px`,
                width: `${Math.abs(selectionBox.width)}px`,
                height: `${Math.abs(selectionBox.height)}px`
            }"
          ></div>

          <div class="skill-connections-container">
            <!-- Connections between skills -->
            <div
              v-for="connection in connections"
              :key="connection.id"
              class="connection"
              :class="{ active: isConnectionActive(connection), 'connection-hover': connection.isHovered,  dotted: connection.dotted }"
              :style="connectionStyleGetter(connection)"
              @mouseenter="!isPanning && (connection.isHovered = true)"
              @mouseleave="!isPanning && (connection.isHovered = false)"
              @click.stop="editConnection(connection)"
              @touchstart.stop.prevent="editConnection(connection)"
              @contextmenu.prevent.stop="removeConnection(connection)"
            >
              <div class="connection-hitbox"></div>
              <div v-show="showArrows" class="connection-after"></div>
            </div>
            <!-- Control Points on connections -->
            <!--<div
              v-for="connection in connections"
              :key="'cp-' + connection.id"
              class="control-point"
              :style="{
  left: connection.controlPoint.x + 'px',
  top: connection.controlPoint.y + 'px'
}"
              @mousedown.stop="startDragControlPoint($event, connection)"
              @click.stop="editConnection(connection)"
            ></div>-->

            <!-- Skills -->
            <div
              v-for="(skill, index) in skills"
              :key="skill.id"
              :data-skill-id="skill.id"
              class="skill"
              :class="{
                        'inactive': skill.currentPoints === 0,
                        'unlockable': canAddPoint(skill, 'no warning') && skill.currentPoints === 0,
                        'animate-in': skill.shouldAnimate,
                        'initial-skill': index < 4,
                        'skilled': skill.currentPoints > 0
                        //'selected': selectedSkills.includes(skill.id)'
                    }"
              :style="{
                //transform: `translate3d(${skill.x - 1000}px, ${skill.y - 1000}px, 0)`,
                        left: skill.x + 'px',
                        top: skill.y + 'px',
                        opacity: skill.shouldAnimate ? 1 : 0,
                        visibility:  hideLockedSkills >= 1 && this.maxPoints != this.totalPointsSpent && !canAddPoint(skill, 'no warning') ? 'hidden' : 'visible',
                        width: skill.size + 'px',
                        height: skill.size + 'px',
                        borderStyle: skill.borderType === 'dashed' ? skill.borderType : 'solid',
                        borderRadius: skill.shape === 'round' ? '50%' : '0',
                        backgroundColor: 'rgb(21, 21, 21)'
                    }"
              @contextmenu.prevent="decrementPoints(skill)"
              @click.stop="!$event.shiftKey && toggleActions(skill)"
              @mousedown.left="startDrag($event, skill)"
              @touchstart.stop="handleSkillTouch($event, skill)"
              @touchend.stop="handleSkillTouchEnd(skill)"
              @mouseenter="skillMouseEnter(skill)"
              @mouseleave="skillMouseLeave(skill)"
              @click.shift.stop="toggleSkillSelection(skill)"
            >
              <!--
            this keeps good perforamnce on selection but not on panning           
            v-memo="[
    skill.currentPoints,
    skill.showTooltip,
    skill.showActions,
    skill.shouldAnimate,
    skill.x,
    skill.y,
    skill.size,
    hideLockedSkills,
    showSkillNames,
    maxPoints,
    totalPointsSpent
  ]"-->
              <!--borderColor: skill.currentPoints < 1 ? 'rgb(106, 103, 103)' : 'rgb(255, 215, 0)',-->
              <div v-if="showSkillNames" class="skill-name">{{ skill.name }}</div>
              <img
                :src="skill.image"
                :alt="skill.name"
                @load="handleImageLoad($event)"
                style="
                  width: 100%;
                  height: 100%;
                  border-radius: 50%;
                  object-fit: cover;
                  color: transparent;
                  opacity: 0;
                  transition: opacity 0.3s ease;
                "
              />
              <div class="skill-points">{{ skill.currentPoints }}/{{ skill.maxPoints }}</div>

              <!-- Add the tooltip -->
              <div
                class="skill-tooltip"
                v-show="skill.showTooltip"
                :class="getTooltipPosition(skill)"
                @mousedown.stop
                @mouseup.stop
                @click.stop
                @touchstart.stop
                @touchend.stop
              >
                <h3>{{ skill.name }}</h3>
                <div
                  class="skill-requirements"
                  v-if="getUnmetRequirements(skill).length > 0 && showRequirementsTooltip"
                >
                  <div
                    v-for="requirement in getUnmetRequirements(skill)"
                    :key="requirement"
                    class="requirement-item"
                  >
                    {{ requirement }}
                  </div>
                </div>
                <p style="white-space: pre-wrap">{{ skill.description || '' }}</p>
                <div class="resources-container" v-if="skill.resources?.length">
                  <div class="resources-container" v-if="skill.resources?.length">
                    <div
                      v-for="r in skill.resources"
                      :key="r.name"
                      class="resource-row"
                      :style="{color: r.color}"
                    >
                      {{ r.name }}{{ r.value ? ': ' + (r.value.toLowerCase().includes('rank') ?
                      calculateRankValue(r.value, skill.rank || 1) : parseStatValue(r.value,
                      skill.currentPoints)) : '' }}
                    </div>
                  </div>
                </div>
                <p class="damage" v-if="skill.damage">Damage: {{ skill.damage }}</p>
              </div>

              <!-- Action buttons -->
              <div v-show="skill.showActions" class="skill-actions">
                <button
                  class="action-btn"
                  @click.stop="editSkill(skill)"
                  @touchstart.stop.prevent="editSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Edit skill')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  
                </button>
                <button
                  class="action-btn"
                  @click.stop="deleteSkill(skill)"
                  @touchstart.stop.prevent="deleteSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Delete skill')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  
                </button>
                <button
                  class="action-btn"
                  @click.stop="connectSkill(skill)"
                  @touchstart.stop.prevent="connectSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Connect to another skill. Left click on the destination.')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  
                </button>
                <button
                  class="action-btn"
                  @click.stop="splitSkill(skill)"
                  @touchstart.stop.prevent="splitSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Split into two mutually exclusive skills')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        v-show="showLoadModal"
        class="load-modal-backdrop"
        :class="{ active: showLoadModal }"
        @click="showLoadModal = false"
      >
        <div class="load-modal" :class="{ active: showLoadModal }" @click.stop>
          <div class="options-section">
            <h3>Load Options</h3>
            <div class="option-group button-group">
              <button class="btn" @click="showLoadModal = false" style="color: white !important">
                Cancel
              </button>
              <button class="btn" @click="loadTree('merge')">Merge with Current</button>
              <button class="btn" @click="loadTree('overwrite')">Overwrite Tree</button>
            </div>
          </div>
        </div>
      </div>

      <div class="bottom-left-buttons">
        <!-- Add options button and panel -->
        <button
          class="options-button"
          @click="toggleOptions"
          @mouseenter="showActionTooltip($event, 'Options')"
          @mouseleave="hideActionTooltip($event)"
        >
          
        </button>
        <button
          class="discord-button"
          @click="openDiscord"
          @mouseenter="showActionTooltip($event, 'Feedback is Welcome!')"
          @mouseleave="hideActionTooltip($event)"
        >
          <img src="/img/discord-logo.png" alt="" style="width: 17px; height: 17px" />
        </button>
        <div class="options-panel" v-show="showOptions">
          <div class="options-section">
            <h3>Class Settings</h3>
            <div class="option-group">
              <label
                for="className"
                title="This changes the text displayed at the bottom of the skill tree"
                >Class Name</label
              >
              <input
                type="text"
                id="className"
                v-model="currentName"
                placeholder="Enter class name..."
              />
            </div>
            <div class="option-group">
              <label
                title="This is the maximum number of points that can be spent on the skill tree"
                >Max Points</label
              >
              <input
                type="number"
                v-model="maxPoints"
                min="1"
                @change="saveToHistory"
                placeholder="Maximum points allowed"
              />
            </div>
            <div class="option-group">
              <label title="This can be overridden in each skill's individual settings"
                >Skill Unlock</label
              >
              <select v-model="prerequisiteMode">
                <option value="none">No Previous Skills Required</option>
                <option value="one">At Least One Skill Required</option>
                <option default value="all">All Previous Skills Required</option>
              </select>
            </div>
            <div class="option-group">
              <label> Skill Unlock Display </label>
              <select v-model="hideLockedSkills">
                <option value="0">Always Show All Skills</option>
                <option value="1">Hide Skills When Requirements Not Met</option>
                <option value="2">Hide Skills And Connections When Requirements Not Met</option>
              </select>
            </div>
            <div class="option-group">
              <label>Total Stats Panel</label>
              <select v-model="showStatsSummary" @change="showStatValue">
                <option :value="false">Hide</option>
                <option :value="true">Show</option>
              </select>
            </div>
          </div>

          <div class="options-section">
            <h3>Editor Settings</h3>
            <div class="option-group">
              <label>Mode</label>
              <select v-model="mode" @change="handleModeChange">
                <option value="edit">Edit Mode</option>
                <option value="view">View Mode</option>
                <option value="game">Game Mode</option>
                <option value="frozen">Frozen Mode</option>
              </select>
            </div>

            <div v-if="mode === 'edit'" class="option-group">
              <!-- <label>Grid Settings</label> -->
              <label>
                Use Grid
                <input type="checkbox" v-model="showGlobalGrid" />
              </label>
              <div class="grid-controls">
                <template v-if="showGlobalGrid">
                  <input type="range" v-model="gridOpacity" min="0" max="100" />
                  <span>Opacity: {{ gridOpacity }}%</span>
                  <input type="range" v-model="gridSize" min="20" max="300" />
                  <span>Size: {{ gridSize }}px</span>
                </template>
              </div>
            </div>

            <div v-if="!showGlobalGrid && mode === 'edit'" class="option-group">
              <div class="snap-controls">
                <label> Enable Snap </label>
                <input type="checkbox" v-model="gridSnapEnabled" @change="saveToHistory" />

                <!-- <label>Snap Threshold</label> -->
                <input
                  type="range"
                  v-model="snapThreshold"
                  min="1"
                  max="300"
                  placeholder="Snap threshold"
                />
                <span>Snap Threshold: {{ snapThreshold }}px</span>
              </div>
            </div>
          </div>

          <div class="options-section">
            <h3>Visual Settings</h3>

            <div class="option-group">
              <label>Background Color</label>
              <div class="color-controls">
                <input type="color" v-model="overlayColor" @input="updateBackground" />
                <input
                  type="range"
                  v-model="overlayOpacity"
                  min="0"
                  max="100"
                  @input="updateBackground"
                />
                <span>{{ overlayOpacity }}%</span>
              </div>
            </div>
            <div class="option-group">
              <label>Background Image</label>
              <div class="recent-backgrounds">
                <div
                  v-for="bg in recentBackgrounds"
                  :key="bg.id"
                  class="background-thumbnail"
                  :style="{ backgroundImage: `url(${bg.src})` }"
                  @click="currentBackgroundLink = bg.src; updateBackground()"
                ></div>
              </div>
              <div style="display: flex; gap: 10px; align-items: center">
                <input
                  type="file"
                  accept="image/*"
                  style="display: none"
                  ref="bgImageUpload"
                  @change="handleBackgroundUpload"
                />
                <button class="btn upload-button" @click="$refs.bgImageUpload.click()">
                  Upload Background
                </button>
              </div>
            </div>
            <div class="option-group">
              <label>Tree Unlock Color</label>
              <div class="color-controls">
                <input type="color" v-model="treeUnlockColor" @input="updateTreeUnlockColor" />
                <!--<input
                  type="range"
                  v-model="selectionOpacity"
                  min="0"
                  max="100"
                  @input="updateTreeUnlockColor"
                /> 
                <span>{{ selectionOpacity }}%</span>-->
              </div>
            </div>
            <div class="option-group">
              <label>Connection Width</label>
              <div class="range-container">
                <input
                  type="range"
                  v-model="config.connection.height"
                  min="0"
                  max="20"
                  step="0.5"
                />
                <span>{{ config.connection.height }}px</span>
              </div>
            </div>
            <div class="option-group">
              <label
                >Show Arrows
                <input type="checkbox" v-model="showArrows" />
              </label>
            </div>
            <!-- <div class="option-group">
              <label>Skill Size Presets</label>
              <div class="size-preset-controls">
                <div class="preset-group">
                  <label>Small</label>
                  <input type="range" v-model="skillSizePresets.small" min="30" max="50" step="2" />
                  <span>{{skillSizePresets.small}}px</span>
                </div>
                <div class="preset-group">
                  <label>Medium</label>
                  <input type="range" v-model="skillSizePresets.medium" min="51" max="70" step="2" />
                  <span>{{skillSizePresets.medium}}px</span>
                </div>
                <div class="preset-group">
                  <label>Large</label>
                  <input type="range" v-model="skillSizePresets.large" min="71" max="100" step="2" />
                  <span>{{skillSizePresets.large}}px</span>
                </div>
              </div>
            </div> -->
            <div class="option-group">
              <label>Skill Shape</label>
              <select v-model="skillShape" @change="updateSkillShape">
                <option value="round">Round</option>
                <option value="square">Square</option>
                <option value="diamond">Diamond</option>
                <option value="hexagon">Hexagon</option>
              </select>
            </div>
            <div class="option-group">
              <label>Show Skill Names</label>
              <select v-model="showSkillNames">
                <option :value="false">Hide</option>
                <option :value="true">Show</option>
              </select>
            </div>
            <div class="option-group">
              <label>Show Requirements Description</label>
              <select v-model="showRequirementsTooltip">
                <option :value="false">Hide</option>
                <option :value="true">Show</option>
              </select>
            </div>
          </div>

          <div class="options-section">
            <h3>New Skill Defaults</h3>

            <div class="option-group">
              <label>Default Max Skill Points</label>
              <input
                type="number"
                v-model="defaultMaxSkillPoints"
                min="1"
                placeholder="Default max skill points for new skills"
                title="Default max skill points for new skills"
              />
              <!-- @change="updateDefaultMaxSkillPoints" -->
              <div style="margin-top: 8px">
                <img
                  :src="defaultSkillImage"
                  style="width: 40px; height: 40px; border-radius: 50%"
                />
              </div>
              <button class="btn" @click="openDefaultImageSelector">Set Default Skill Image</button>
            </div>
            <div class="option-group">
              <label>Add New Skill On Click</label>
              <select v-model="addSkillOnClick">
                <option :value="false">No</option>
                <option :value="true">Yes</option>
              </select>
            </div>
            <div class="option-group">
              <label>Keep Tooltip Open</label>
              <select v-model="keepTooltipOpen">
                <option :value="false">No</option>
                <option :value="true">Yes</option>
              </select>
            </div>
          </div>

          <div class="options-section">
            <h3>Auto Formating</h3>

            <div class="option-group button-group" style="margin-top: 10px">
              <button class="btn" @click="autoFormatCircle">Auto Format Skills From Circle</button>
            </div>
          </div>

          <div class="options-section">
            <h3>Import/Download</h3>
            <div class="option-group button-group">
              <button class="btn" @click="importFromJson"> Load/Import JSON</button>
              <button class="btn" @click="exportToJson"> Save/Download JSON</button>
            </div>
            <div class="option-group button-group">
              <button class="btn" @click="exportToGAS">
                 Export for Unreal Gameplay Ability System
              </button>
            </div>
            <div class="option-group button-group">
              <button class="btn" @click="exportToDataTable">
                 Export for Unreal Data Table (CSV)
              </button>
            </div>
          </div>
        </div>

        <div
          class="points-display"
          v-if="currentName"
          @mouseenter="showActionTooltip($event, 'Total Points Spent / Max Points')"
          @mouseleave="hideActionTooltip($event)"
        >
          {{ totalPointsSpent }} / {{ maxPoints }}
        </div>
        <button
          class="load-button"
          @click="importFromJson"
          @mouseenter="showActionTooltip($event, 'Load Skill Tree')"
          @mouseleave="hideActionTooltip($event)"
        >
          
        </button>
        <button
          class="download-button"
          @click="exportToJson"
          style="margin-left: 50px"
          @mouseenter="showActionTooltip($event, 'Save Skill Tree')"
          @mouseleave="hideActionTooltip($event)"
        >
          
        </button>
        <button
          class="share-button"
          @click="shareTree"
          @mouseenter="showActionTooltip($event, 'Share Tree')"
          @mouseleave="hideActionTooltip($event)"
        >
          
        </button>
      </div>

      <button
        class="info-btn"
        @click="showInfo=!showInfo"
        @mouseenter="showActionTooltip($event, 'Quick Guide and FAQ')"
        @mouseleave="hideActionTooltip($event)"
      >
        
      </button>
      <div class="info-panel" v-if="showInfo">
        <h3>Quick Guide</h3>
        <ul>
          <li>Click anywhere to create a skill</li>
          <li>Click a skill to edit, then click again to add points</li>
          <li>Right-click a skill to remove points</li>
          <li>Click and drag a skill to move it</li>
          <li>Right-click and drag to pan the grid</li>
          <li>Click a connection to edit it</li>
          <li>Click and drag to select multiple skills</li>
          <li>Shift+Click to select multiple skills</li>
          <li>Ctrl+A to select all skills</li>
          <li>Ctrl+C/V to copy/paste selected skills</li>
          <li>Delete key to delete selected skills</li>
          <li>Alt+Click to edit skill</li>
        </ul>

        <h3>Stats Syntax</h3>
        <ul>
          <li>Basic stat: "10" or "10%"</li>
          <li>Per skill point scaling: "[5 * CurrentPoints] damage"</li>
          <li>Level-based: "[Level 1: 1d4, Level 2: 2d6] damage"</li>
          <li>Tree-based: "[4 * SpentTreePoints / TreeMaxPoints] damage"</li>
        </ul>

        <h3>FAQ</h3>
        <ul>
          <li>
            <strong>Q: How do I change backgrounds?</strong><br />
            A: Click the options button () in the bottom left corner, <br />then upload a
            background image. <br />(Small as possible for best performance)
          </li>

          <li>
            <strong>Q: How do I save my tree?</strong><br />
            A: Click the save icon () to download as JSON
          </li>

          <li>
            <strong>Q: How do I share my tree?</strong><br />
            A: Click the share icon () to get a shareable link
          </li>
        </ul>
      </div>
      <button
        class="twitter-btn"
        @click="openAdditionalWebsite"
        @mouseenter="showActionTooltip($event, 'Support the development')"
        @mouseleave="hideActionTooltip($event)"
      >
        <div class="inner-button"></div>
        <!--  -->
      </button>
      <div class="stats-panel" v-if="showStatsSummary">
        <h3>Total Stats</h3>
        <div v-for="(s,n) in totalStats" :key="n" :style="{color:s.color}">
          {{n}}: {{s.total}}{{s.isPercent ? '%' : ''}}
        </div>
      </div>

      <!-- Connection Options Modal -->
      <div
        v-if="editingConnection"
        class="edit-modal-backdrop"
        :class="{ active: editingSkill }"
        @click="cancelEditConnection"
      >
        <div class="edit-modal" @click.stop>
          <div class="edit-form-container">
            <h2 class="edit-skill-title">Edit Connection</h2>
            <!--            <div class="edit-field row">
              <label>
                <input type="checkbox" v-model="selectedConnection.hasControlPoint" />
                Add Control Point
              </label>
            </div>

            <div class="edit-field">
              <label>
                <input type="checkbox" v-model="selectedConnection.mutuallyExclusive" />
                Mutually Exclusive Connection
              </label>
              <small
                >Other skills connected to this control point cannot be active simultaneously</small
              >
            </div>-->

            <div
              class="option-group"
              title="Display this connection as a dotted line instead of solid"
            >
              <label class="option-edit-label">Connection Line Style (Solid or Dotted)</label>
              <select v-model="selectedConnection.dotted">
                <option :value="false">Solid Line</option>
                <option :value="true">Dotted Line</option>
              </select>
            </div>

            <div class="edit-field">
              <button
                class="delete-connection-btn"
                @click="removeConnection(selectedConnection)"
                style="
                  background: #ff4747;
                  color: white;
                  border: none;
                  padding: 8px 16px;
                  border-radius: 4px;
                  cursor: pointer;
                  margin-top: 10px;
                "
              >
                Delete Connection
              </button>
            </div>

            <small
              >Coming soon - the ability to make t-junctions and shapes with connections.</small
            >

            <div class="edit-modal-buttons">
              <button class="edit-modal-button cancel-button" @click="cancelEditConnection">
                Cancel
              </button>
              <button class="edit-modal-button save-button" @click="saveEditConnection">
                Save
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Edit Modal -->
      <div
        v-if="editingSkill"
        class="edit-modal-backdrop"
        :class="{ active: editingSkill }"
        @click="cancelEdit"
      >
        <div class="edit-modal" @click.stop>
          <div class="skill-preview-container">
            <div
              class="skill-preview"
              :class="{ 'skilled': editingSkill.currentPoints > 0 }"
              @click="openImageSelector"
              @touchstart.prevent="openImageSelector"
              style="cursor: pointer"
              :style="{
                borderStyle: editingSkill.borderType || 'solid',
                borderRadius: editingSkill.shape === 'round' ? '50%' : '0',
                width: editingSkill.size + 'px',
                height: editingSkill.size + 'px',
              }"
            >
              <img :src="editingSkill.image" :alt="editingSkill.name" />
              <div class="skill-points">
                {{ editingSkill.currentPoints }}/{{ editingSkill.maxPoints }}
              </div>
            </div>

            <div class="skill-appearance-controls">
              <div class="control-group">
                <!-- <label>Size</label> -->
                <div class="radio-group">
                  <input type="range" v-model="editingSkill.size" min="0" max="110" step="1" />
                  <span>{{editingSkill.size}}px</span>
                  <label>
                    <input
                      type="radio"
                      v-model="editingSkill.size"
                      :value="skillSizePresets.small"
                    />
                    Small
                  </label>
                  <label>
                    <input
                      type="radio"
                      v-model="editingSkill.size"
                      :value="skillSizePresets.medium"
                    />
                    Medium
                  </label>
                  <label>
                    <input
                      type="radio"
                      v-model="editingSkill.size"
                      :value="skillSizePresets.large"
                    />
                    Large
                  </label>
                </div>
              </div>

              <div class="control-group">
                <!-- <label>Shape</label> -->
                <div class="radio-group">
                  <label>
                    <input type="radio" v-model="editingSkill.shape" value="round" />
                    Round
                  </label>
                  <label>
                    <input type="radio" v-model="editingSkill.shape" value="square" />
                    Square
                  </label>
                  <!-- <label>
                    <input type="radio" v-model="editingSkill.shape" value="diamond">
                    Diamond
                  </label>
                  <label>
                    <input type="radio" v-model="editingSkill.shape" value="hexagon">
                    Hex
                  </label> -->
                </div>
              </div>

              <div class="control-group">
                <!-- <label>Border Style</label> -->
                <div class="radio-group">
                  <label>
                    <input type="radio" v-model="editingSkill.borderType" value="solid" />
                    Solid
                  </label>
                  <!-- <label>
                    <input type="radio" v-model="editingSkill.borderType" value="groove">
                    Groove
                  </label> -->
                  <label>
                    <input type="radio" v-model="editingSkill.borderType" value="dashed" />
                    Dashed
                  </label>
                </div>
              </div>
            </div>
          </div>
          <div class="edit-form-container">
            <h2 class="edit-skill-title">
              {{ selectedSkills.length > 1 ? "Editing All Selected Skills" : "Edit Skill"}}
            </h2>
            <div class="edit-field">
              <label>Name</label>
              <input
                v-model="editingSkill.name"
                type="text"
                @keyup.enter="saveEdit"
                ref="nameInput"
              />
              <!-- <div style="display: flex; align-items: center; gap: 5px">
                <button
                  class="rank-btn"
                  @click="decrementRank(editingSkill)"
                  :disabled="editingSkill.rank <= 1"
                >
                  
                </button>
                <span class="rank-span">Rank {{ editingSkill.rank || 1 }}</span>
                <button
                  class="rank-btn"
                  @click="incrementRank(editingSkill)"
                  :disabled="editingSkill.rank >= editingSkill.maxPoints"
                >
                  
                </button>
              </div> -->
            </div>
            <div class="edit-field row" style="margin-bottom: 0px">
              <!-- <label  @mouseenter="showGenerateTooltip($event, 'Points spent in tree to unlock')"
              @mouseleave="hideGenerateTooltip($event)">Requirements</label> -->

              <!-- <div class="option-group">
                <label>Show Requirements</label>
                <select v-model="showRequirements">
                  <option value="global" default> Global Setting On/Off</option>
                  <option value="on">On</option>
                  <option value="off">Off</option>
                </select>
              </div> -->

              <div>
                <label title="Total points needed in the entire tree to unlock this skill"
                  >Required Points In Tree</label
                >
                <input
                  v-model="editingSkill.requiredPoints"
                  min="0"
                  type="number"
                  placeholder="0"
                  style="margin-top: 0px; margin-bottom: 15px"
                />
              </div>

              <div class="option-group">
                <label
                  class="option-edit-label"
                  title="This overrides the global unlock setting for the entire tree. Per skill settings coming soon."
                  >Required To Unlock This Skill</label
                >
                <select v-model="prerequisiteMode" class="option-group-select">
                  <option value="none">No Previous Skills Required</option>
                  <option value="one">At Least One Skill Required</option>
                  <option default value="all">All Previous Skills Required</option>
                </select>
              </div>

              <!-- <div>
                <label title="The amount of points needed for this skill to be fully unlocked"
                  >Skill Level To Unlock Next Skill</label
                >
                <input
                  v-model="editingSkill.requiredPoints"
                  min="0"
                  type="number"
                  placeholder="0"
                  style="margin-top: 0px"
                />
              </div>-->
            </div>

            <div class="edit-field">
              <label>Description</label>
              <textarea
                v-model="editingSkill.description"
                placeholder="Enter skill description..."
                style="white-space: pre-wrap"
              ></textarea>
            </div>
            <div class="edit-field">
              <label
                @mouseenter="showGenerateTooltip($event, 'Points spent in tree to unlock')"
                @mouseleave="hideGenerateTooltip($event)"
                >Resources/Stats</label
              >
              <div id="resources-container">
                <div
                  v-for="(resource, index) in editingSkill.resources"
                  :key="index"
                  class="edit-field row edit-resource-row"
                  draggable="true"
                  @dragstart="dragStart($event, index)"
                  @dragover.prevent
                  @drop="drop($event, index)"
                  @mousedown="handleResourceRowMouseDown($event)"
                >
                  <input
                    v-model="resource.name"
                    type="text"
                    placeholder="Name"
                    :style="{color: resource.color}"
                  />
                  <input
                    v-model="resource.value"
                    type="text"
                    placeholder="Value"
                    :style="{color: resource.color}"
                  />
                  <input
                    v-model="resource.color"
                    type="text"
                    placeholder="Color"
                    :style="{color: resource.color}"
                  />
                  <!-- <div class="drag-handle"></div> -->
                  <button @click="editingSkill.resources.splice(index, 1)"></button>
                </div>
              </div>
              <button
                class="add-resource"
                @click="editingSkill.resources?.push({name:'',value:'',color:'#ffffff'})"
              >
                + Add Resource
              </button>
            </div>
            <div class="edit-field row">
              <div>
                <label title="Points spent to unlock an additional skill level"
                  >Cost Per Skill Level</label
                >
                <input v-model="editingSkill.cost" min="0" type="number" placeholder="1" />
              </div>

              <div>
                <label title="Current skill level of this skill">Current Skill Level</label>
                <input
                  v-model="editingSkill.currentPoints"
                  type="number"
                  min="0"
                  :max="editingSkill.maxPoints"
                  placeholder="Current"
                />
              </div>
              <div>
                <label title="Max points the skill can have">Max Skill Level</label>
                <input
                  v-model="editingSkill.maxPoints"
                  type="number"
                  min="1"
                  max="20"
                  placeholder="Max"
                />
              </div>
            </div>

            <div class="edit-modal-buttons">
              <button class="edit-modal-button cancel-button" @click="cancelEdit">Cancel</button>
              <button class="edit-modal-button save-button" @click="saveEdit">Save</button>
            </div>
          </div>
        </div>
      </div>
      <div
        v-if="showImageSelector"
        class="image-selector-modal"
        :class="{ active: showImageSelector }"
      >
        <h2 style="color: #ffd100; margin-bottom: 20px">Select Skill Image</h2>
        <!-- Add this inside the image selector modal, just before the image grid -->
        <div class="image-upload-section">
          <div class="upload-row">
            <div class="image-upload-column">
              <label for="imageUpload" class="upload-button" id="imageUpload2">
                 Upload Custom Image
                <input
                  type="file"
                  id="imageUpload"
                  accept="image/*"
                  style="display: none"
                  @change="handleImageUpload"
                />
              </label>
              <div class="upload-info">
                Supports PNG, JPG, GIF <br />
                (Saved in your browser.)<br />
                (Make images as small as possible for best performance.) <br />
                (Each image will increase save file size.)
              </div>
            </div>
            <!-- <span class="divider">or</span> -->
            <div class="url-upload">
              <label class="upload-button" @click="handleUrlUpload" id="urlUpload"
                > Link Image</label
              >

              <input
                type="text"
                v-model="imageUrl"
                placeholder="Enter image URL here..."
                class="url-input"
              />
              <div class="upload-info">
                Copy the image url above, then click "Link Image". <br />
                Only the link is saved, not the image data itself.<br />
              </div>
            </div>
          </div>
        </div>
        <!-- Update the existing image grid -->
        <div class="image-grid">
          <!-- <img
          v-for="image in allImages"
          :key="image.id"
          :src="image.src"
          :class="['image-option', { selected: selectedImage === image.id }]"
          @click="selectImage(image)"
          :alt="image.name"
        /> -->
          <div
            v-for="image in allImages"
            :key="image.id"
            style="position: relative; display: inline-block"
          >
            <img
              :src="image.src"
              :class="['image-option', { selected: selectedImage === image.id }]"
              @click="selectImage(image)"
              :alt="image.name"
            />
            <button
              v-if="!image.isDefault"
              @click.stop="removeImage(image)"
              class="remove-image-btn"
              style="
                position: absolute;
                top: 0;
                left: 55px;
                background: rgba(0, 0, 0, 0.99);
                color: rgb(255, 71, 71);
                border: none;
                border-radius: 50%;
                width: 18px;
                height: 18px;
                font-size: 12px;
                cursor: pointer;
                z-index: 2;
              "
              title="Remove image"
            >
              
            </button>
          </div>
        </div>
        <div class="image-selector-buttons">
          <button class="edit-modal-button cancel-button" @click="cancelImageSelection">
            Cancel
          </button>
          <button class="edit-modal-button save-button" @click="saveImageSelection">Save</button>
        </div>
      </div>

      <div class="class-title" v-if="currentName">{{ currentName }}</div>

      <div class="history-controls">
        <button
          class="history-btn"
          @click="undo"
          :disabled="!canUndo"
          title="Undo"
          @mouseenter="showActionTooltip($event, 'Undo (Ctrl+Z)')"
          @mouseleave="hideActionTooltip($event)"
        >
          
        </button>
        <button
          class="history-btn"
          @click="redo"
          :disabled="!canRedo"
          title="Redo"
          @mouseenter="showActionTooltip($event, 'Redo (Ctrl+Y)')"
          @mouseleave="hideActionTooltip($event)"
        >
          
        </button>
      </div>
    </div>

    <script>
      const { createApp } = Vue;

      // Global configuration object
      const CONFIG = {
        paths: {
          assets: "/src/app/assets",
          config: "/src/app/config",
          images: {
            skills: "/img/skill",
            backgrounds: "/img/background",
            default: "/img/skill/axe-hammer-grey.png",
          },
        },
        grid: {
          spacing: 120,
          startX: 100,
          startY: 100,
        },
        skill: {
          size: 100, // diameter of skill circle
          offset: 30, // half of size, used for centering
        },
        connection: {
          height: 2, // Default connection height
        },
        skillImages: [
          "/axe-hammer-grey.png",
          "/fire-orb.png",
          "/fire-rock.png",
          "/flaming-spear.png",
          "/flaming-staff.png",
          "/golden-arrow.png",
          "/gray-spear.png",
          "/ornate-spear.png",
          "/skull-blue.png",
          "/small-trident.png",
          "/spectral-dagger.png",
          "/water-sword.png",
        ],
      };

      createApp({
        data() {
          return {
            hideLockedSkills: 0, // 0 = show all, 1 = hide skills, 2 = hide skills and connections
            totalStats: {},
            showInfo: false,
            showStatsSummary: false, //window.innerWidth > 768,
            config: CONFIG, // Make config available in template
            skills: [],
            connections: [],
            connectingFrom: null,
            skillIdCounter: 0,
            draggedSkill: null,
            dragOffset: { x: 0, y: 0 },
            draggedElement: null,
            isDragging: false,
            isLinking: false,
            hoveredSkill: null,
            defaultMaxPoints: 5, // Add this default value
            dragStartTime: null,
            dragStartPos: null,
            dragThreshold: 5, // pixels of movement to consider it a drag
            showOptions: false,
            isPanning: false,
            panStart: { x: 0, y: 0 },
            treePosition: { x: 0, y: 0 },
            scale: 1,
            minScale: 0.5,
            maxScale: 2,
            scaleStep: 0.1,
            isLoaded: false,
            touchStartX: null,
            touchStartY: null,
            lastTouchDistance: null,
            touchTimeout: null,
            doubleTapDelay: 300, // milliseconds
            lastTap: 0,
            editingSkill: null,
            oldSkills: null,
            oldBackgroundLink: null,
            oldName: null,
            currentBackgroundLink: null,
            currentName: null,
            currentClassDescription: null,
            inputText: "",
            isLoading: false,
            history: [],
            historyIndex: -1,
            maxHistorySize: 50,
            showImageSelector: false,
            selectedImage: null,
            availableImages: CONFIG.skillImages,
            skillShape: "round",
            customImages: [],
            gridSnapEnabled: true, // Add this new property
            snapThreshold: 8,
            mode: "edit",
            overlayColor: "#000000",
            overlayOpacity: 75,
            showArrows: true,
            showGlobalGrid: false,
            gridOpacity: 12,
            gridSize: window.innerWidth <= 768 ? 80 : 120, // Default grid size based on screen width
            maxPoints: 20, // Default max points
            selectionBox: null,
            selectedSkills: [],
            initialClick: { x: 0, y: 0 },
            showLoadModal: false,
            loadedData: null,
            recentBackgrounds: JSON.parse(localStorage.getItem("recentBackgrounds") || "[]"),
            initialPositions: null,
            prerequisiteMode: "all",
            showGenerateControls: true,
            lastPanTime: 0,
            treeEl: null,
            imageUrl: "",
            defaultSkillImage: CONFIG.paths.images.default,
            defaultMaxSkillPoints: 5,
            selectingDefaultImage: false,
            showSkillNames: false,
            skillSizePresets: {
              small: 30,
              medium: 60,
              large: 110,
            },
            showRequirementsTooltip: true,
            skillNamesSize: 12,
            selectedConnection: null,
            editingConnection: false,
            controlPoints: [],
            addSkillOnClick: true,
            treeUnlockColor: "#ffd700",
            treeUnlockBoxshadow: "0 0 5px rgba(0, 0, 0, 0.5)",
            treeLockedColor: "#FF0000",
            treeLockedBoxshadow: "0 0 5px rgba(0, 0, 0, 0.5)",
            showNews: true,
            keepTooltipOpen: false,
          };
        },

        computed: {
          canUndo() {
            return this.history.length >= 2 && this.historyIndex > 1;
          },
          canRedo() {
            return this.historyIndex < this.history.length - 1;
          },
          allImages() {
            // Convert default images to the same format as custom images
            const defaultImages = this.availableImages.map((image) => ({
              id: image,
              src: this.config.paths.images.skills + image,
              name: image,
              isDefault: true,
            }));

            // Combine with custom images
            return [...defaultImages, ...this.customImages];
          },
          gridStyle() {
            return {
              "--grid-opacity": this.gridOpacity / 100,
            };
          },

          gridLines() {
            if (!this.showGlobalGrid) return [];

            const lines = [];

            if (!this.treeEl) return lines;
            // console.log("treeEl", this.treeEl);
            const bounds = this.treeEl.getBoundingClientRect();
            const extendedBounds = {
              width: bounds.width * 10,
              height: bounds.height * 10,
            };
            const size = parseInt(this.gridSize);

            // Calculate the offset based on tree position
            const offsetX = this.treePosition.x % size;
            const offsetY = this.treePosition.y % size;

            // Calculate number of lines needed
            const numHorizontal = Math.ceil(extendedBounds.height / size);
            const numVertical = Math.ceil(extendedBounds.width / size);

            // Add horizontal lines
            for (let i = 0; i <= numHorizontal; i++) {
              lines.push({
                id: `h${i}`,
                type: "horizontal",
                style: {
                  top: `${i * size + offsetY}px`,
                },
              });
            }

            // Add vertical lines
            for (let i = 0; i <= numVertical; i++) {
              lines.push({
                id: `v${i}`,
                type: "vertical",
                style: {
                  left: `${i * size + offsetX}px`,
                },
              });
            }

            return lines;
          },
          totalPointsSpent() {
            return this.skills.reduce(
              (total, skill) => total + skill.currentPoints * (skill.cost || 1),
              0
            );
          },
          //   connectionStyleGetter() {
          //     return (connection) => {
          //       const fromSkill = this.skills.find((s) => s.id === connection.from);
          //       const toSkill = this.skills.find((s) => s.id === connection.to);

          //       if (!fromSkill || !toSkill) return {};

          //       const dx = toSkill.x - fromSkill.x;
          //       const dy = toSkill.y - fromSkill.y;
          //       // const angle = (Math.atan2(dy, dx) * 180) / Math.PI;
          //       const angle = (Math.atan2(dy, dx) * 180) / Math.PI;
          //       const length = Math.sqrt(dx * dx + dy * dy);

          //       return {
          //         left: `${fromSkill.x + (fromSkill.size / 2)}px`,
          //         top: `${fromSkill.y + (fromSkill.size / 2)}px`,
          //         width: `${length}px`,
          //         height: `${this.config.connection.height}px`,
          //         transform: `rotate(${angle}deg)`,
          //       };
          //     };
          //   },
          // },
          connectionStyleGetter() {
            return (connection) => {
              const from = this.skills.find((s) => s.id === connection.from);
              const to = this.skills.find((s) => s.id === connection.to);
              if (!from || !to) return {};

              /*  1. centres of both skill icons  */
              const fromC = { x: from.x + from.size / 2, y: from.y + from.size / 2 };
              const toC = { x: to.x + to.size / 2, y: to.y + to.size / 2 };

              /*  2. vector, angle and distance between centres  */
              const dx = toC.x - fromC.x;
              const dy = toC.y - fromC.y;
              const angleRad = Math.atan2(dy, dx);
              const angleDeg = (angleRad * 180) / Math.PI;
              const centreDistance = Math.hypot(dx, dy);

              /*  3. radii of the two icons + (optional) arrowhead length  */
              const r1 = from.size / 2;
              const r2 = to.size / 2;
              // const arrowHead = this.config.connection.arrowHead ?? 0; // px
              const arrowHead = 0;

              /*  4. shift the start point outwards by r1 on the vector  */
              const startX = fromC.x + Math.cos(angleRad) * r1;
              const startY = fromC.y + Math.sin(angleRad) * r1;

              /*  5. final length is centre distance minus the two radii  */
              const length = centreDistance - r1 - r2 - arrowHead;

              if (this.hideLockedSkills == 2) {
                // 2 == hide skills and connections
                if (from.currentPoints < 1 && to.currentPoints < 1) {
                  return {};
                }
              }

              return {
                position: "absolute",
                left: `${startX}px`,
                top: `${startY}px`,
                width: `${length}px`,
                height: `${this.config.connection.height}px`,
                transform: `rotate(${angleDeg}deg)`,
                transformOrigin: "0 50%", // pivot around the bars leftcentre
                /* any other style props you already set */
              };
            };
          },
        },
        mounted() {
          // Check if we're loading a specific tree
          const match = window.location.pathname.match(/\/tree\/([^\/]+)/);
          if (match) {
            const treeId = match[1];
            this.loadTreeById(treeId);
          } else {
            this.loadDefaultConfig();
          }

          // Add keyboard event listener
          document.addEventListener("keydown", this.handleKeyboardShortcuts);

          setTimeout(() => {
            document.querySelector(".talent-tree").classList.add("loaded");
            this.saveToHistory(); // Save initial state
          }, 1000);

          // Load custom images from localStorage
          this.loadCustomImages();

          this.mode = new URLSearchParams(window.location.search).get("mode") || "edit";
          document.body.classList.toggle("view-mode", this.mode === "view");
          document.body.classList.toggle("game-mode", this.mode === "game");

          if (this.mode === "view" || this.mode === "game" || this.mode === "frozen") {
            this.showGlobalGrid = false;
            this.showGenerateControls = false;
          } else {
            this.showGlobalGrid = true;
          }

          // Set zoom tree dimensions to exact pixel values
          const zoomTree = document.querySelector(".zoom-tree");
          if (zoomTree) {
            zoomTree.style.width = `${window.innerWidth * 2}px`;
            zoomTree.style.height = `${window.innerHeight * 2}px`;
          }

          window.addEventListener("resize", this.handleResize);

          this.treeEl = document.querySelector(".talent-tree");
        },
        beforeUnmount() {
          // Clean up event listener
          document.removeEventListener("keydown", this.handleKeyboardShortcuts);
          window.removeEventListener("resize", this.handleResize);
        },
        methods: {
          handleKeyboardShortcuts(event) {
            // Check if ctrl/cmd key is pressed
            if (event.ctrlKey || event.metaKey) {
              if (event.key === "z") {
                event.preventDefault();
                // Only allow undo when there are at least 2 states in history
                if (this.history.length >= 2 && this.historyIndex > 0) {
                  this.undo();
                }
              } else if (event.key === "y") {
                event.preventDefault();
                if (this.canRedo) {
                  this.redo();
                }
              } else if (event.key === "c") {
                this.copy();
              } else if (event.key === "v") {
                this.paste();
              } else if (event.key.toLowerCase() === "g") {
                event.preventDefault();
                this.toggleGenerateControls();
              } else if (event.key.toLowerCase() === "a") {
                // if (!this.editingSkill) {
                const isTextInputFocused =
                  document.activeElement.tagName === "INPUT" ||
                  document.activeElement.tagName === "TEXTAREA";

                if (!isTextInputFocused) {
                  event.preventDefault();
                  this.selectAllSkills();
                }
              }
            } else if (event.key === "Delete") {
              // Get all selected skills
              // const selectedSkills = this.skills.filter((skill) =>
              //   this.selectedSkills.includes(skill.id)
              // );
              const isTextInputFocused =
                document.activeElement.tagName === "INPUT" ||
                document.activeElement.tagName === "TEXTAREA";

              if (!isTextInputFocused && this.editingSkill === null) {
                this.saveToHistory();
                // // Delete each selected skill using existing deleteSkill method
                this.selectedSkills.forEach((skill) => {
                  this.deleteSkill(skill);
                });
              }
              // Clear selection
              // this.deselectAllSkills();
              // // Save state to history
              // this.saveToHistory();
            }
          },
          loadDefaultConfig() {
            fetch(`${this.config.paths.config}/default.json`)
              .then((response) => response.json())
              .then((data) => {
                this.skills = [];
                this.connections = [];

                // Set the initial class name and background
                const isMobile = window.innerWidth <= 768;

                // Set the initial class name and background
                this.currentName = isMobile
                  ? "Try Tapping A Skill"
                  : "Try Generating a Class, or Clicking a Skill.";

                this.currentBackgroundLink = data["Class Image"]
                  ? `${this.config.paths.images.backgrounds}${data["Class Image"]}`
                  : "/img/background/grass-ancient.jpg";

                // First pass: Create a map of skill dependencies and levels
                const skillLevels = new Map();
                const skillDeps = new Map();

                data.Skills.forEach((skill) => {
                  const name = skill["Skill Name"];
                  skillDeps.set(
                    name,
                    skill["Skill Prerequisite"] !== "-"
                      ? skill["Skill Prerequisite"].split(" (")[0]
                      : null
                  );
                });

                // Calculate levels based on prerequisites
                const calculateLevel = (skillName, visited = new Set()) => {
                  if (visited.has(skillName)) return 0; // Handle circular dependencies
                  visited.add(skillName);

                  const prereq = skillDeps.get(skillName);
                  if (!prereq) return 0;

                  return 1 + calculateLevel(prereq, visited);
                };

                // Assign levels to all skills
                data.Skills.forEach((skill) => {
                  const level = calculateLevel(skill["Skill Name"]);
                  skillLevels.set(skill["Skill Name"], level);
                });

                // Group skills by level
                const skillsByLevel = new Map();
                skillLevels.forEach((level, name) => {
                  if (!skillsByLevel.has(level)) {
                    skillsByLevel.set(level, []);
                  }
                  skillsByLevel.get(level).push(name);
                });

                // Calculate positions
                data.Skills = data.Skills.map((skill) => {
                  if (!skill["Skill Position"]) {
                    const level = skillLevels.get(skill["Skill Name"]);
                    const skillsAtLevel = skillsByLevel.get(level);
                    const indexAtLevel = skillsAtLevel.indexOf(skill["Skill Name"]);

                    // Calculate grid position
                    // Level determines x (column), index within level determines y (row)
                    const x = level + 1; // Add 1 to avoid x=0
                    const y = indexAtLevel + 1;

                    skill["Skill Position"] = `(${x},${y})`;
                  }
                  return skill;
                });

                // Continue with existing positioning logic...
                const viewport = {
                  width: window.innerWidth,
                  height: window.innerHeight,
                };

                // Find bounds of the skill tree
                let minX = Infinity,
                  minY = Infinity,
                  maxX = -Infinity,
                  maxY = -Infinity;

                // First pass: calculate bounds
                data.Skills.forEach((skillData) => {
                  const posMatch = skillData["Skill Position"].match(/\((\d+),\s*(\d+)\)/);
                  const x = parseInt(posMatch[1]);
                  const y = parseInt(posMatch[2]);

                  const gridX = this.config.grid.startX + (x - 1) * this.config.grid.spacing;
                  const gridY = this.config.grid.startY + (y - 1) * this.config.grid.spacing;

                  minX = Math.min(minX, gridX);
                  minY = Math.min(minY, gridY);
                  maxX = Math.max(maxX, gridX);
                  maxY = Math.max(maxY, gridY);
                });

                // Calculate center offset
                const treeWidth = maxX - minX;
                const treeHeight = maxY - minY;
                const offsetX = viewport.width - treeWidth - treeWidth / 2;
                const offsetY = viewport.height - treeHeight - treeHeight / 2 + 250;

                // Second pass: create skills with centered positions
                data.Skills.forEach((skillData, index) => {
                  const posMatch = skillData["Skill Position"].match(/\((\d+),\s*(\d+)\)/);
                  const x = parseInt(posMatch[1]);
                  const y = parseInt(posMatch[2]);

                  const initialX =
                    this.config.grid.startX + (x - 1) * this.config.grid.spacing + offsetX;
                  const initialY =
                    this.config.grid.startY + (y - 1) * this.config.grid.spacing + offsetY;

                  // Snap to grid
                  // Use the same snapToGrid method as drag operations
                  const snappedPos = this.snapToGrid(initialX, initialY);
                  if (skillData["size"] !== undefined) {
                    const snappedPos = this.snapToGrid(initialX, initialY, skillData["size"]);
                  }

                  const skill = {
                    id: ++this.skillIdCounter,
                    name: skillData["Skill Name"],
                    x: snappedPos.x,
                    y: snappedPos.y,
                    showActions: false,
                    level: skillData["Skill Level"],
                    // damage: skillData["Skill Damage"],
                    description: skillData["Skill Description"],
                    maxPoints: skillData["Skill Max Points"] || this.defaultMaxPoints,
                    currentPoints: index < 4 ? 1 : skillData["Skill Current Points"] || 0,
                    image: `${this.config.paths.images.skills}${skillData["Skill Image"]}`,
                    shouldAnimate: false,
                    resources: [],
                    size: this.skillSizePresets.medium, // Default to medium size
                    borderType: "solid", // Default border style
                    shape: "round",
                    cost: 1,
                    prerequisiteModeOverride: "global", // "global", "one", "all"
                    exclusiveSkillIds: [], // ids of skills that are exclusive to this skill, used in connections
                  };
                  // Add damage to resources if it exists
                  if (skillData["Skill Damage"]) {
                    skill.resources.push({
                      name: "Damage",
                      value: skillData["Skill Damage"],
                      color: "#ff4747",
                    });
                  }

                  this.skills.push(skill);

                  // Create connection if there's a prerequisite
                  if (skillData["Skill Prerequisite"] !== "-") {
                    const prereqName = skillData["Skill Prerequisite"].split(" (")[0];
                    const prereqSkill = this.skills.find((s) => s.name === prereqName);
                    if (prereqSkill) {
                      this.connections.push({
                        id: `${prereqSkill.id}-${skill.id}`,
                        from: prereqSkill.id,
                        to: skill.id,
                        hasControlPoint: false,
                        controlPoint: this.calculateMidpoint(prereqSkill, skill),
                        mutuallyExclusive: false,
                        dotted: false,
                      });
                    }
                  }
                });

                // Trigger animations with a slight delay for each skill
                setTimeout(() => {
                  this.skills.forEach((skill, index) => {
                    setTimeout(() => {
                      skill.shouldAnimate = true;
                    }, index * 50); // 50ms delay between each skill
                  });
                }, 100); // Initial delay of 100ms

                // Initialize history with the initial state
                this.history = [];
                this.historyIndex = -1; // Reset history index

                // Force an initial state save after everything is loaded
                this.$nextTick(() => {
                  if (this.skills.length > 0) {
                    this.saveToHistory();
                  }
                });
                this.totalStats = this.calculateTotalStats();
              })
              .catch((error) => console.error("Error loading default config:", error));
          },
          getAdjustedCoordinates(oldX, oldY, scale) {
            // Calculate the offset factor using the quadratic function:
            // f(s) = -0.5 * s^2 + 1.75 * s - 0.75
            // const offsetFactor = -0.5 * scale * scale + 1.75 * scale - 0.75;

            // // Adjust x and y using the corresponding window dimensions
            // const x = oldX / scale + window.innerWidth * offsetFactor;
            // const y = oldY / scale + window.innerHeight * offsetFactor;

            const x = oldX / scale + (window.innerWidth / 2) * (2 - 1 / scale);
            const y = oldY / scale + (window.innerHeight / 2) * (2 - 1 / scale);

            return { x, y };
          },
          handleClick(event) {
            if (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) return;
            // Don't create skill if we just finished making a selection
            // if (!this.selectionBox) {
            // if (!event.target.classList.contains('skill')) {
            // this.selectedSkills = []; // Clear selection when clicking empty space
            // }
            // return;
            // }

            //base equation event.offsetX / this.scale + ( window.innerWidth) / 2
            //scale 0.5 : event.offsetX * 2
            //sclae 1 :  + window.innerWidth/2
            //scale 2 : event.offsetX / this.scale + (1.5 * window.innerWidth) / 2
            // x * 2 = 1.5
            const adjustedCoordinates = this.getAdjustedCoordinates(
              event.offsetX,
              event.offsetY,
              this.scale
            );

            if (!this.isDragging && event.target.classList.contains("talent-tree")) {
              if (!this.isDragging && this.selectionBox === null) {
                if (this.addSkillOnClick) {
                  this.createSkill(
                    adjustedCoordinates.x, // + window.innerWidth / 2,
                    adjustedCoordinates.y // + window.innerHeight / 2
                  );
                } else {
                  this.deselectAllSkills();
                }
              }
            }
            this.isDragging = false;
          },

          createSkill(x, y) {
            this.deselectAllSkills();

            const skill = {
              id: ++this.skillIdCounter,
              x: x - this.config.skill.offset,
              y: y - this.config.skill.offset,
              name: `Skill ${this.skillIdCounter}`,
              showActions: false,
              showTooltip: false,
              description: "Click to edit skill description.",
              // damage: '0',
              maxPoints: this.defaultMaxSkillPoints,
              currentPoints: 0,
              requiredPoints: 0,
              // image: this.config.paths.images.default,
              image: this.defaultSkillImage,
              shouldAnimate: true, // Set to true immediately
              resources: [],
              size: this.skillSizePresets.medium, // Default to medium size
              borderType: "solid", // Default border style
              shape: "round",
              cost: 1,
              prerequisiteModeOverride: "global", // "global", "one", "all"
              exclusiveSkillIds: [], // ids of skills that are exclusive to this skill, used in connections
            };
            if (this.showGlobalGrid) {
              const snappedPos = this.snapToGrid(x, y, skill.size);
              skill.x = snappedPos.x;
              skill.y = snappedPos.y;
            }
            this.skills.push(skill);
            this.saveToHistory();

            // Force the image to be visible immediately after creation
            this.$nextTick(() => {
              const skillElement = document.querySelector(`[data-skill-id="${skill.id}"] img`);
              if (skillElement) {
                skillElement.style.opacity = "1";
              }
            });
          },

          toggleActions(skill) {
            if (this.isFrozenMode()) return;
            if (
              this.currentName === "Try Generating a Class, or Clicking a Skill." ||
              this.currentName === "Try Tapping A Skill"
            ) {
              this.currentName = " ";
            }
            // Only process click if we haven't dragged
            if (!this.isDragging) {
              if (event.altKey) {
                this.editSkill(skill);
                return;
              }
              if (this.isLinking) {
                // If we're in linking mode, treat this as the second skill
                this.connectSkill(skill);
                return;
              }

              // Deselect all skills only if this skill is not already selected
              if (!this.selectedSkills.includes(skill)) {
                this.deselectAllSkills();
              }

              // Hide all other action menus
              // this.skills.forEach((s) => {
              //   if (s.id !== skill.id) s.showActions = false;
              // });

              // Increment points only on clean click
              if (skill.currentPoints < skill.maxPoints) {
                if (this.isViewMode() || this.isGameMode()) {
                  if (this.canAddPoint(skill)) {
                    skill.currentPoints++;
                    this.totalStats = this.calculateTotalStats();
                  }
                } else {
                  if (skill.showActions) {
                    //Avoid increment if first click to edit skil
                    if (this.canAddPoint(skill)) {
                      skill.currentPoints++;
                      this.totalStats = this.calculateTotalStats();
                    }
                  } else {
                    skill.showActions = true;
                    this.selectedSkills.push(skill);
                  }
                  console.log("selectedSkills", this.selectedSkills.length);
                }
              }

              if (this.isViewMode() || this.isGameMode()) return;

              // Don't toggle if actions are already shown
              // if (!skill.showActions) {
              //   skill.showActions = true;
              // }
            }
          },

          editSkill(skill) {
            // Ensure resources is initialized when editing
            this.editingSkill = {
              ...skill,
              resources: skill.resources || [],
            };

            // used to check which part of the skill has been modified in this editing session
            this.editingSkill._initialName = skill.name;
            this.editingSkill._initialDescription = skill.description;
            this.editingSkill._initialDamage = skill.damage;
            this.editingSkill._initialImage = skill.image;
            this.editingSkill._initialMaxPoints = skill.maxPoints;
            this.editingSkill._initialCurrentPoints = skill.currentPoints;
            this.editingSkill._initialRequiredPoints = skill.requiredPoints;
            this.editingSkill._initialResources = skill.resources || [];
            this.editingSkill._initialSize = skill.size;
            this.editingSkill._initialBorderType = skill.borderType;
            this.editingSkill._initialShape = skill.shape;
            this.editingSkill._initialCost = skill.cost;
            this.editingSkill._initialPrerequisiteModeOverride = skill.prerequisiteModeOverride;
            this.editingSkill._initialExclusiveSkillIds = skill.exclusiveSkillIds;

            // Focus name input after modal opens
            this.$nextTick(() => {
              this.$refs.nameInput?.focus();
            });
          },

          saveEdit() {
            if (!this.editingSkill) return;

            // single skill edit
            if (this.selectedSkills.length <= 1) {
              const skill = this.skills.find((s) => s.id === this.editingSkill.id);
              if (skill) {
                skill.name = this.editingSkill.name;
                skill.description = this.editingSkill.description;
                skill.damage = this.editingSkill.damage;
                skill.image = this.editingSkill.image;

                // Handle max points and current points changes
                const newMaxPoints = parseInt(this.editingSkill.maxPoints);
                const newCurrentPoints = parseInt(this.editingSkill.currentPoints);
                const newRequiredPoints = parseInt(this.editingSkill.requiredPoints);
                skill.maxPoints = newMaxPoints;
                skill.currentPoints = Math.min(newCurrentPoints, newMaxPoints); // Update current points
                skill.requiredPoints = newRequiredPoints;
                skill.resources = this.editingSkill.resources || [];
                skill.size = this.editingSkill.size;
                skill.borderType = this.editingSkill.borderType;
                skill.shape = this.editingSkill.shape;
                skill.cost = this.editingSkill.cost;
                skill.prerequisiteModeOverride = this.editingSkill.prerequisiteModeOverride;
                skill.exclusiveSkillIds = this.editingSkill.exclusiveSkillIds;
                // console.log("skill", skill);

                if (this.showGlobalGrid) {
                  const snappedPos = this.snapToGrid(skill.x, skill.y, skill.size);
                  skill.x = snappedPos.x;
                  skill.y = snappedPos.y;
                }

                this.totalStats = this.calculateTotalStats();
              }
            } else {
              // multiple skill edit
              console.log("in multiple skill edit");
              this.selectedSkills.forEach((skill) => {
                // const skill = this.skills.find((s) => s.id === skill.id);
                if (skill) {
                  // If updated the name or field this editing sessions
                  // Check if each field has been modified in this editing session by comparing with initial state
                  if (this.editingSkill.name !== this.editingSkill._initialName) {
                    skill.name = this.editingSkill.name;
                  }
                  if (this.editingSkill.description !== this.editingSkill._initialDescription) {
                    skill.description = this.editingSkill.description;
                  }
                  if (this.editingSkill.damage !== this.editingSkill._initialDamage) {
                    skill.damage = this.editingSkill.damage;
                  }
                  if (this.editingSkill.image !== this.editingSkill._initialImage) {
                    skill.image = this.editingSkill.image;
                  }
                  if (this.editingSkill.currentPoints !== this.editingSkill._initialCurrentPoints) {
                    skill.currentPoints = parseInt(this.editingSkill.currentPoints);
                  }
                  if (this.editingSkill.maxPoints !== this.editingSkill._initialMaxPoints) {
                    skill.maxPoints = parseInt(this.editingSkill.maxPoints);
                    skill.currentPoints = Math.min(
                      parseInt(this.editingSkill.currentPoints),
                      skill.maxPoints
                    );
                  }
                  if (
                    this.editingSkill.requiredPoints !== this.editingSkill._initialRequiredPoints
                  ) {
                    skill.requiredPoints = parseInt(this.editingSkill.requiredPoints);
                  }
                  if (
                    JSON.stringify(this.editingSkill.resources) !==
                    JSON.stringify(this.editingSkill._initialResources)
                  ) {
                    skill.resources = this.editingSkill.resources || [];
                  }
                  if (this.editingSkill.size !== this.editingSkill._initialSize) {
                    skill.size = this.editingSkill.size;
                  }
                  if (this.editingSkill.borderType !== this.editingSkill._initialBorderType) {
                    skill.borderType = this.editingSkill.borderType;
                  }
                  if (this.editingSkill.shape !== this.editingSkill._initialShape) {
                    skill.shape = this.editingSkill.shape;
                  }
                  if (this.editingSkill.cost !== this.editingSkill._initialCost) {
                    skill.cost = this.editingSkill.cost;
                  }
                  if (
                    this.editingSkill.prerequisiteModeOverride !==
                    this.editingSkill._initialPrerequisiteModeOverride
                  ) {
                    skill.prerequisiteModeOverride = this.editingSkill.prerequisiteModeOverride;
                  }
                  if (
                    this.editingSkill.exclusiveSkillIds !==
                    this.editingSkill._initialExclusiveSkillIds
                  ) {
                    skill.exclusiveSkillIds = this.editingSkill.exclusiveSkillIds;
                  }

                  // want to override skills in another
                  // skill.name = this.editingSkill.name;
                }
              });
            }

            this.editingSkill = null;
            this.showImageSelector = false;
            this.saveToHistory();
          },

          cancelEdit() {
            this.editingSkill = null;
          },

          deleteSkill(skill) {
            this.skills = this.skills.filter((s) => s.id !== skill.id);
            this.connections = this.connections.filter(
              (c) => c.from !== skill.id && c.to !== skill.id
            );
          },

          connectSkill(skill) {
            if (!this.connectingFrom) {
              // Starting a new connection
              this.connectingFrom = skill;
              this.isLinking = true;
              // Hide actions menu and all tooltips
              this.skills.forEach((s) => {
                s.showActions = false;
                s.showTooltip = false;
              });
            } else {
              // Completing a connection
              if (this.connectingFrom.id !== skill.id) {
                this.connections.push({
                  id: `${this.connectingFrom.id}-${skill.id}`,
                  from: this.connectingFrom.id,
                  to: skill.id,
                  hasControlPoint: false,
                  controlPoint: this.calculateMidpoint(this.connectingFrom, skill),
                  mutuallyExclusive: false,
                  dotted: false,
                });
              }
              // Reset connection state
              this.connectingFrom = null;
              this.isLinking = false;
            }
            this.saveToHistory();
          },

          getConnectionStyle(connection) {
            const fromSkill = this.skills.find((s) => s.id === connection.from);
            const toSkill = this.skills.find((s) => s.id === connection.to);

            if (!fromSkill || !toSkill) return {};

            const dx = toSkill.x - fromSkill.x;
            const dy = toSkill.y - fromSkill.y;
            const angle = (Math.atan2(dy, dx) * 180) / Math.PI;
            const length = Math.sqrt(dx * dx + dy * dy);

            return {
              left: `${fromSkill.x + 30}px`,
              top: `${fromSkill.y + 30}px`,
              width: `${length}px`,
              height: `${this.config.connection.height}px`,
              transform: `rotate(${angle}deg)`,
            };
          },

          startDrag(event, skill) {
            if (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) return;

            event.preventDefault();
            let pointerOld = event.touches ? event.touches[0] : event;
            const adjustedCoordinates = this.getAdjustedCoordinates(
              pointerOld.clientX,
              pointerOld.clientY,
              this.scale
            );
            let pointer = {
              clientX: adjustedCoordinates.x,
              clientY: adjustedCoordinates.y,
            };

            // Store initial positions of selected skills
            this.initialPositions = {};
            // this.selectedSkills.forEach((skill) => {
            //   if (skill) {
            //     this.initialPositions[skill.id] = { x: skill.x, y: skill.y };
            //   }
            // });
            this.selectedSkills.forEach((selectedSkill) => {
              if (selectedSkill) {
                this.initialPositions[selectedSkill.id] = {
                  x: selectedSkill.x - skill.x, // Store relative offset from dragged skill
                  y: selectedSkill.y - skill.y,
                };
              }
            });

            // Store initial position and time
            this.dragStartTime = Date.now();
            this.dragStartPos = {
              x: pointer.clientX,
              y: pointer.clientY,
            };

            this.isDragging = false; // Reset drag state
            this.draggedSkill = skill;
            const treeRect = event.target.closest(".talent-tree").getBoundingClientRect();

            this.draggedElement = event.target.closest(".skill");

            this.dragOffset = {
              x: pointer.clientX - (skill.x + treeRect.left),
              y: pointer.clientY - (skill.y + treeRect.top),
            };

            // Add event listeners
            if (event.touches) {
              document.addEventListener("touchmove", this.handleDrag, { passive: false });
              document.addEventListener("touchend", this.stopDrag);
            } else {
              document.addEventListener("mousemove", this.handleDrag);
              document.addEventListener("mouseup", this.stopDrag);
            }
          },

          handleDrag(event) {
            if (!this.draggedSkill) return;

            let pointerOld = event.touches ? event.touches[0] : event;
            const adjustedCoordinates = this.getAdjustedCoordinates(
              pointerOld.clientX,
              pointerOld.clientY,
              this.scale
            );
            let pointer = {
              clientX: adjustedCoordinates.x,
              clientY: adjustedCoordinates.y,
              pageX: adjustedCoordinates.x,
              pageY: adjustedCoordinates.y,
            };
            // pointer.pageX = 500;
            // pointer.pageY = adjustedCoordinates.y;
            // Move selected skills
            // if (this.draggedSkill) {
            //     const dx = event.clientX - this.dragOffset.x - this.draggedSkill.x;
            //     const dy = event.clientY - this.dragOffset.y - this.draggedSkill.y;

            //     const skillsToMove = [...new Set([...this.selectedSkills, this.draggedSkill])];
            //     skillsToMove.forEach(skill => {
            //         skill.x += dx;
            //         skill.y += dy;
            //     });
            // }

            // Check if movement exceeds drag threshold
            if (!this.isDragging) {
              const dx = pointer.pageX - this.dragStartPos.x;
              const dy = pointer.pageY - this.dragStartPos.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance > this.dragThreshold) {
                this.isDragging = true;
              }
            }

            if (this.isDragging) {
              const treeRect = document.querySelector(".talent-tree").getBoundingClientRect();
              const newX = pointer.pageX - this.dragOffset.x - treeRect.left - window.scrollX;
              const newY = pointer.pageY - this.dragOffset.y - treeRect.top - window.scrollY;

              let finalX = newX;
              let finalY = newY;

              if (this.gridSnapEnabled) {
                // Find nearby skills for snapping
                const snapThreshold = this.snapThreshold;
                const nearbySkills = this.skills.filter(
                  (skill) =>
                    skill.id !== this.draggedSkill.id &&
                    (Math.abs(skill.x - newX) < 150 || Math.abs(skill.y - newY) < 150) // Consider skills nearby in either direction
                );

                // Find the closest skill in x-direction within threshold
                const closestXSkill = nearbySkills.reduce((closest, skill) => {
                  const distance = Math.abs(skill.x - newX);
                  if (
                    distance < snapThreshold &&
                    (!closest || distance < Math.abs(closest.x - newX))
                  ) {
                    return skill;
                  }
                  return closest;
                }, null);

                // Find the closest skill in y-direction within threshold
                const closestYSkill = nearbySkills.reduce((closest, skill) => {
                  const distance = Math.abs(skill.y - newY);
                  if (
                    distance < snapThreshold &&
                    (!closest || distance < Math.abs(closest.y - newY))
                  ) {
                    return skill;
                  }
                  return closest;
                }, null);

                if (closestXSkill) {
                  finalX = closestXSkill.x;
                }

                if (closestYSkill) {
                  finalY = closestYSkill.y;
                }
              }

              // Apply grid snapping if enabled
              if (this.showGlobalGrid) {
                const snappedPos = this.snapToGrid(newX, newY, this.draggedSkill.size);

                finalX = snappedPos.x;
                finalY = snappedPos.y;
              }

              // Calculate movement delta
              const dx = finalX - this.dragStartPos.x;
              const dy = finalY - this.dragStartPos.y;

              if (!this.draggedElement || !this.draggedSkill) return; // Early return if elements are missing
              requestAnimationFrame(() => {
                this.draggedElement.style.left = `${finalX}px`;
                this.draggedElement.style.top = `${finalY}px`;

                this.draggedSkill.x = finalX;
                this.draggedSkill.y = finalY;

                // console.log("selectedSkills", this.selectedSkills)
                // Move all other selected skills maintaining relative positions
                // this.selectedSkills.forEach((skillInArray) => {
                //   if (skillInArray.id !== this.draggedSkill.id) {
                //     let skill = this.skills.find((s) => s.id === skillInArray.id);
                //     if (skill) {
                //       skill.x =
                //         finalX -
                //         this.dragStartPos.x +
                //         30 +
                //         this.initialPositions[skillInArray.id].x;
                //       skill.y =
                //         finalY -
                //         this.dragStartPos.y +
                //         30 +
                //         this.initialPositions[skillInArray.id].y;
                //       const skillElement = document.querySelector(`[data-skill-id="${skill.id}"]`);
                //       if (skillElement) {
                //         skillElement.style.left = `${skill.x}px`;
                //         skillElement.style.top = `${skill.y}px`;
                //       }
                //     }
                //   }
                // });
                this.selectedSkills.forEach((skillInArray) => {
                  if (skillInArray.id !== this.draggedSkill.id) {
                    let skill = this.skills.find((s) => s.id === skillInArray.id);
                    if (skill) {
                      const relativePos = this.initialPositions[skillInArray.id];
                      skill.x = finalX + relativePos.x; // Use relative position directly
                      skill.y = finalY + relativePos.y;

                      const skillElement = document.querySelector(`[data-skill-id="${skill.id}"]`);
                      if (skillElement) {
                        skillElement.style.left = `${skill.x}px`;
                        skillElement.style.top = `${skill.y}px`;
                      }
                    }
                  }
                });
              });
            }
          },

          stopDrag() {
            this.selectionBox = null;
            // Don't reset isDragging immediately
            const wasDragging = this.isDragging;

            this.draggedSkill = null;
            this.initialPositions = null; // Clean up the initial positions

            // Use setTimeout to reset isDragging after click events have processed
            setTimeout(() => {
              this.isDragging = false;
            }, 0);

            // Remove event listeners
            document.removeEventListener("mousemove", this.handleDrag);
            document.removeEventListener("mouseup", this.stopDrag);
            document.removeEventListener("touchmove", this.handleDrag);
            document.removeEventListener("touchend", this.stopDrag);
          },

          showActionTooltip(event, text) {
            const tooltip = document.createElement("div");
            tooltip.className = "action-btn-tooltip";
            if (text === "Edit skill" && this.selectedSkills.length > 1) {
              text = "Edit skills";
            }
            tooltip.textContent = text;
            event.target.appendChild(tooltip);
          },

          hideActionTooltip(event) {
            const tooltip = event.target.querySelector(".action-btn-tooltip");
            if (tooltip) {
              tooltip.remove();
            }
          },

          decrementPoints(skill) {
            if (this.isFrozenMode()) return;
            if (skill.currentPoints > 0) {
              skill.currentPoints--;

              // Only check dependent skills if in view/game mode and points were fully removed
              if (
                (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) &&
                skill.currentPoints === 0
              ) {
                this.checkAndRemoveDependentSkills(skill);
              }

              this.totalStats = this.calculateTotalStats();
            }
          },
          checkAndRemoveDependentSkills(skill) {
            // Get all outgoing connections from this skill
            const outgoingConnections = this.connections.filter((conn) => conn.from === skill.id);

            // Check each dependent skill
            outgoingConnections.forEach((conn) => {
              const dependentSkill = this.skills.find((s) => s.id === conn.to);
              if (dependentSkill && dependentSkill.currentPoints > 0) {
                // Check if the dependent skill still meets requirements
                if (!this.canAddPoint(dependentSkill, "no warning")) {
                  // If requirements not met, recursively remove points
                  while (dependentSkill.currentPoints > 0) {
                    dependentSkill.currentPoints--;
                    if (dependentSkill.currentPoints === 0) {
                      this.checkAndRemoveDependentSkills(dependentSkill);
                    }
                  }
                }
              }
            });
          },

          isConnectionActive(connection) {
            const fromSkill = this.skills.find((s) => s.id === connection.from);
            const toSkill = this.skills.find((s) => s.id === connection.to);
            return fromSkill?.currentPoints > 0 && toSkill?.currentPoints > 0;
          },

          toggleOptions() {
            this.showOptions = !this.showOptions;
          },
          handleImageLoad(event) {
            event.target.style.opacity = "1";
          },

          startPan(event) {
            if (event.button === 0 && event.target.classList.contains("talent-tree")) {
              // Left click for selection box
              if (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) return;
              event.preventDefault();
              let adjustedCoordinates = this.getAdjustedCoordinates(
                event.offsetX,
                event.offsetY,
                this.scale
              );
              this.initialClick = {
                x: adjustedCoordinates.x,
                y: adjustedCoordinates.y,
              };
              document.addEventListener("mousemove", this.handleSelection);
              document.addEventListener("mouseup", this.stopSelection);
            }
            if (event.button === 2) {
              // Right click
              event.preventDefault();
              this.isPanning = true;
              this.panStart = {
                x: event.clientX - this.treePosition.x,
                y: event.clientY - this.treePosition.y,
              };
              document.addEventListener("mousemove", this.handlePan);
              document.addEventListener("mouseup", this.stopPan);
            }
          },

          handlePan(event) {
            if (this.isPanning) {
              requestAnimationFrame(() => {
                // Update all skill positions
                this.skills.forEach((skill) => {
                  skill.x += event.movementX;
                  skill.y += event.movementY;

                  // const newSkillX = skill.x + event.movementX;
                  // const newSkillY = skill.y + event.movementY;

                  // Object.defineProperty(skill, "x", {
                  //   value: newSkillX,
                  //   configurable: true,
                  //   enumerable: true,
                  // });
                  // Object.defineProperty(skill, "y", {
                  //   value: newSkillY,
                  //   configurable: true,
                  //   enumerable: true,
                  // });

                  //         const skillElement = document.querySelector(`[data-skill-id="${skill.id}"]`);
                  // if (skillElement) {
                  //   skillElement.style.transform = `translate3d(${newX}px, ${newY}px, 0)`;
                  // }
                });
                const newX = event.clientX - this.panStart.x;
                const newY = event.clientY - this.panStart.y;
                this.treePosition = { x: newX, y: newY };
              });

              // Force grid recomputation by triggering reactivity
              if (this.showGlobalGrid) {
                // this.$forceUpdate();
              }
            }
          },

          stopPan() {
            this.isPanning = false;
            document.removeEventListener("mousemove", this.handlePan);
            document.removeEventListener("mouseup", this.stopPan);
          },

          handleZoom(event) {
            event.preventDefault();

            // Determine zoom direction
            let zoomIn = event.deltaY < 0;
            if (event.deltaY !== undefined) {
              // Mouse wheel
              zoomIn = event.deltaY < 0;
            } else {
              // Pinch zoom
              zoomIn = event.scale > 1;
            }

            // Calculate new scale
            let newScale = this.scale + (zoomIn ? this.scaleStep : -this.scaleStep);

            // Clamp scale between min and max values
            newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));

            // // Only proceed if scale actually changed
            // if (newScale !== this.scale) {
            //   // Get mouse position relative to the tree
            //   const rect = event.target.getBoundingClientRect();
            //   const mouseX = event.clientX - rect.left;
            //   const mouseY = event.clientY - rect.top;

            //   // Calculate scale factor
            //   const scaleFactor = newScale / this.scale;

            //   // Update all skill positions relative to mouse position
            //   this.skills.forEach((skill) => {
            //     skill.x = mouseX + (skill.x - mouseX) * scaleFactor;
            //     skill.y = mouseY + (skill.y - mouseY) * scaleFactor;
            //   });

            //   const skillElements = document.querySelectorAll(".skill");
            //   skillElements.forEach((element) => {
            //     // element.style.transform = `scale(${newScale})`;
            //     // Adjust the hit area for interactions
            //     // element.style.width = `${60 - 10 / newScale}px`;
            //     // element.style.height = `${60 - 10 / newScale}px`;
            //   });

            const container = document.querySelector(".zoom-tree");
            if (container) {
              container.style.transform = `translate(-25%, -25%) scale(${newScale})`;
              // container.style.transformOrigin = "center center";
            }
            // const skills = document.querySelector(".skill-connections-container");
            // if (skills) {
            //   skills.style.transform = `scale(${newScale})`;
            //   skills.style.transformOrigin = "center center";
            // }

            // if (this.showGlobalGrid) {
            // Update the tree position slightly to force reactivity
            this.treePosition = {
              x: this.treePosition.x,
              y: this.treePosition.y,
            };

            // Force Vue to recompute the grid lines
            // this.$nextTick(() => {
            // this.$forceUpdate();
            // });
            // }

            this.scale = newScale;
            // }
          },

          exportToJson() {
            this.deselectAllSkills();

            const exportData = {
              Skills: this.skills.map((skill) => {
                // Find all connections where this skill is the prerequisite
                const dependentSkills = this.connections
                  .filter((conn) => conn.from === skill.id)
                  .map((conn) => {
                    const targetSkill = this.skills.find((s) => s.id === conn.to);
                    return targetSkill ? targetSkill.name : null;
                  })
                  .filter((name) => name !== null);

                return {
                  "Skill Name": skill.name,
                  "Skill Position": `(${Math.round(
                    (skill.x - this.config.grid.startX) / this.config.grid.spacing + 1
                  )},${Math.round(
                    (skill.y - this.config.grid.startY) / this.config.grid.spacing + 1
                  )})`,
                  "Skill Position Exact": { x: skill.x, y: skill.y },
                  "Skill Level": skill.level || 1,
                  "Skill Damage": skill.damage,
                  "Skill Description": skill.description,
                  "Skill Max Points": skill.maxPoints,
                  "Skill Current Points": skill.currentPoints,
                  "Skill Image": skill.image.startsWith("data:")
                    ? this.customImages.find((img) => img.src === skill.image)?.id || skill.image
                    : skill.image.split("/img/skill")[1],
                  "Skill Dependencies": dependentSkills, // Add this new field
                  "Skill Prerequisite": this.getPrerequisite(skill),
                  "Skill Resources": skill.resources || [],
                };
              }),
              "Class Name": this.currentName,
              FullData: (() => {
                const fullData = { ...this.$data };
                // Remove specific properties you don't want to include
                delete fullData.recentBackgrounds;
                delete fullData.loadedData;
                delete fullData.history;
                delete fullData.clipboard;
                delete fullData.selectedSkills;
                // delete fullData.customImages;
                return fullData;
              })(),
              // FullData: this.$data,
              // "FullData": {
              //     ...this.$data,
              //     recentBackgrounds: [], // Clear recent backgrounds from full data
              // }
            };

            // Create and trigger download
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);
            const exportFileDefaultName = "talent-tree-config.json";

            const linkElement = document.createElement("a");
            linkElement.setAttribute("href", dataUri);
            linkElement.setAttribute("download", exportFileDefaultName);
            linkElement.click();
          },

          getPrerequisite(skill) {
            const connection = this.connections.find((c) => c.to === skill.id);
            if (!connection) return "-";

            const prereqSkill = this.skills.find((s) => s.id === connection.from);
            return prereqSkill ? `${prereqSkill.name} (${prereqSkill.level || 1})` : "-";
          },

          handleSkillTouch(event, skill) {
            event.preventDefault();

            // Only proceed with skill touch handling if we're not panning
            if (!this.isPanning) {
              if (this.isLinking) {
                this.connectSkill(skill);
                return;
              }

              this.skills.forEach((s) => {
                const el = document.querySelector(`[data-skill-id="${s.id}"]`);
                if (el) {
                  el.style.zIndex = s.id === skill.id ? "1000" : "10";
                }
              });

              const currentTime = new Date().getTime();
              const tapLength = currentTime - this.lastTap;

              // Hide all other tooltips before showing the current one
              this.skills.forEach((s) => {
                if (s.id !== skill.id) {
                  s.showTooltip = false;
                }
              });

              // Show tooltip for current skill
              skill.showTooltip = true;

              // Store touch start position for drag detection
              const touch = event.touches[0];
              this.touchStartX = touch.clientX;
              this.touchStartY = touch.clientY;

              // Start potential drag operation
              this.startDrag(event, skill);

              // Set a timeout to detect if this is a tap or a drag
              this.touchTimeout = setTimeout(() => {
                if (!this.isDragging) {
                  // This was a tap, not a drag
                  if (tapLength < this.doubleTapDelay && tapLength > 0) {
                    // Double tap - decrement points (like right click)
                    if (skill.currentPoints > 0) {
                      skill.currentPoints--;
                    }
                  } else {
                    // Single tap - toggle actions and increment points
                    if (skill.currentPoints < skill.maxPoints && this.canAddPoint(skill)) {
                      skill.currentPoints++;
                    }

                    if (this.isViewMode()) return;

                    this.skills.forEach((s) => {
                      if (s.id !== skill.id) s.showActions = false;
                    });

                    if (!skill.showActions) {
                      skill.showActions = true;
                    }
                  }
                }
              }, 200);

              this.lastTap = currentTime;
            }
          },

          handleSkillTouchEnd(skill) {},

          handleTouchMove(event) {
            if (this.touchTimeout) {
              clearTimeout(this.touchTimeout);
            }

            if (event.touches.length === 1) {
              const touch = event.touches[0];
              const deltaX = touch.clientX - this.touchStartX;
              const deltaY = touch.clientY - this.touchStartY;

              // If we're dragging a skill
              if (this.draggedSkill) {
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                  this.isDragging = true;
                  this.handleDrag(event);
                }
              } else {
                // If we're panning the tree
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                  this.skills.forEach((skill) => {
                    skill.x += deltaX;
                    skill.y += deltaY;
                  });
                  this.touchStartX = touch.clientX;
                  this.touchStartY = touch.clientY;
                }
              }
            } else if (event.touches.length === 2) {
              // Handle pinch zoom
              const touch1 = event.touches[0];
              const touch2 = event.touches[1];
              const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
              );

              if (this.lastTouchDistance) {
                const delta = currentDistance - this.lastTouchDistance;
                const zoomEvent = new WheelEvent("wheel", {
                  deltaY: -delta,
                });
                this.handleZoom(zoomEvent);
              }
              this.lastTouchDistance = currentDistance;
            }
          },

          handleTouchEnd(event) {
            if (this.touchTimeout) {
              clearTimeout(this.touchTimeout);
            }

            if (this.draggedSkill) {
              this.stopDrag();
            }

            this.touchStartX = null;
            this.touchStartY = null;
            this.lastTouchDistance = null;

            // Reset dragging state after a short delay to allow click events to process
            setTimeout(() => {
              this.isDragging = false;
            }, 0);
          },

          generateRandomTree() {
            if (this.skills) {
              this.oldSkills = this.skills;
              this.oldBackgroundLink = this.currentBackgroundLink;
              this.oldName = this.currentName;
            }

            const talentTree = document.querySelector(".talent-tree");
            if (talentTree) {
              talentTree.style.filter = "blur(100px)";
            }

            fetch("/random_tree")
              .then((response) => response.json())
              .then((data) => {
                this.treePosition = { x: 0, y: 0 };
                this.scale = 1;

                const img = new Image();
                img.onload = () => {
                  if (talentTree) {
                    setTimeout(() => {
                      talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${CONFIG.paths.images.backgrounds}${data["Class Image"]}')`;
                      talentTree.style.filter = "blur(0)";
                    }, 100);
                  }
                };
                img.src = CONFIG.paths.images.backgrounds + data["Class Image"];

                this.loadSkillsFromData(data["Skills"]);
                this.currentBackgroundLink = CONFIG.paths.images.backgrounds + data["Class Image"];
                this.currentName = data["Class Name"];
                this.currentClassDescription = data["Class Description"];

                // Save to history after loading
                setTimeout(() => {
                  this.saveToHistory();
                }, 1000);
              })
              .catch((error) => {
                console.error("Error fetching random skill tree:", error);
                if (talentTree) {
                  talentTree.style.opacity = "1";
                  talentTree.style.filter = "blur(0)";
                }
              });
          },

          loadSkillsFromData(skillsData) {
            this.skills = [];
            this.connections = [];
            this.skillIdCounter = 0;

            // First pass: Create a map of skill dependencies and levels
            const skillLevels = new Map();
            const skillDeps = new Map();

            skillsData.forEach((skill) => {
              const name = skill["Skill Name"];
              skillDeps.set(
                name,
                skill["Skill Prerequisite"] !== "-"
                  ? skill["Skill Prerequisite"].split(" (")[0]
                  : null
              );
            });

            // Calculate levels based on prerequisites
            const calculateLevel = (skillName, visited = new Set()) => {
              if (visited.has(skillName)) return 0; // Handle circular dependencies
              visited.add(skillName);

              const prereq = skillDeps.get(skillName);
              if (!prereq) return 0;

              return 1 + calculateLevel(prereq, visited);
            };

            // Assign levels to all skills
            skillsData.forEach((skill) => {
              const level = calculateLevel(skill["Skill Name"]);
              skillLevels.set(skill["Skill Name"], level);
            });

            // Group skills by level
            const skillsByLevel = new Map();
            skillLevels.forEach((level, name) => {
              if (!skillsByLevel.has(level)) {
                skillsByLevel.set(level, []);
              }
              skillsByLevel.get(level).push(name);
            });

            // Calculate positions and create skills
            skillsData.forEach((skillData, index) => {
              let x, y;

              if (skillData["Skill Position"]) {
                const posMatch = skillData["Skill Position"].match(/\((\d+),\s*(\d+)\)/);
                x = parseInt(posMatch[1]);
                y = parseInt(posMatch[2]);
              } else {
                const level = skillLevels.get(skillData["Skill Name"]);
                const skillsAtLevel = skillsByLevel.get(level);
                const indexAtLevel = skillsAtLevel.indexOf(skillData["Skill Name"]);

                // Adjust x position to start more to the left
                x = level; // Removed the +1 to start from 0
                y = indexAtLevel + 1;
              }

              // Adjust starting position and spacing based on viewport width
              const isMobile = window.innerWidth <= 768;
              const startX = isMobile
                ? -40 + (window.innerWidth * 3) / 5
                : this.config.grid.startX + (3 / 4) * window.innerWidth;
              const spacing = isMobile ? 100 : this.config.grid.spacing;
              const verticalOffset = 40 + (window.innerHeight * 3) / 5;

              const initialX = startX + x * spacing;
              const initialY =
                this.config.grid.startY + (y - 1) * this.config.grid.spacing + verticalOffset;
              const snappedPos = this.snapToGrid(initialX, initialY);

              const skill = {
                id: ++this.skillIdCounter,
                name: skillData["Skill Name"],
                x: snappedPos.x,
                y: snappedPos.y,
                showActions: false,
                level: skillData["Skill Level"],
                // damage: skillData["Skill Damage"],
                description: skillData["Skill Description"],
                maxPoints: skillData["Skill Max Points"] || this.defaultMaxPoints,
                currentPoints: index < 4 ? 1 : skillData["Skill Current Points"] || 0,
                requiredPoints: skillData["Required Points"] || 0,
                image: `${this.config.paths.images.skills}${skillData["Skill Image"]}`,
                shouldAnimate: false,
                resources: skillData["Skill Resources"] || [],
                size: skillData["size"] || this.skillSizePresets.medium, // Default to medium size
                borderType: skillData["borderType"] || "solid", // Default border style
                shape: skillData["shape"] || "round",
                cost: skillData["cost"] || 1,
                prerequisiteModeOverride: skillData["prerequisiteModeOverride"] || "global", // "global", "one", "all"
                exclusiveSkillIds: skillData["exclusiveSkillIds"] || [], // ids of skills that are exclusive to this skill, used in connections
              };
              console.log(skillData["shape"] || "round");
              console.log("gell");

              // Add damage to resources if it exists
              if (skillData["Skill Damage"]) {
                skill.resources.push({
                  name: "Damage",
                  value: skillData["Skill Damage"],
                  color: "#ff4747",
                });
              }
              this.skills.push(skill);

              // Create connections
              if (skillData["Skill Prerequisite"] !== "-") {
                const prereqName = skillData["Skill Prerequisite"].split(" (")[0];
                const prereqSkill = this.skills.find((s) => s.name === prereqName);
                if (prereqSkill) {
                  this.connections.push({
                    id: `${prereqSkill.id}-${skill.id}`,
                    from: prereqSkill.id,
                    to: skill.id,
                    hasControlPoint: false,
                    controlPoint: this.calculateMidpoint(prereqSkill, skill),
                    mutuallyExclusive: false,
                    dotted: false,
                  });
                }
              }
              this.totalStats = this.calculateTotalStats();
            });

            // Trigger animations with a slight delay for each skill
            setTimeout(() => {
              this.skills.forEach((skill, index) => {
                setTimeout(() => {
                  skill.shouldAnimate = true;
                }, index * 50); // 50ms delay between each skill
              });
            }, 100); // Initial delay of 100ms
          },

          handleTreeTouchStart(event) {
            if (event.touches.length === 1) {
              const touch = event.touches[0];
              this.isPanning = true;
              this.panStart = {
                x: touch.clientX - this.treePosition.x,
                y: touch.clientY - this.treePosition.y,
              };
              this.touchStartX = touch.clientX;
              this.touchStartY = touch.clientY;

              // Cancel any ongoing drag operations when panning starts
              if (this.draggedSkill) {
                this.stopDrag();
              }
            } else if (event.touches.length === 2) {
              // Initialize pinch zoom
              this.isPanning = false;
              const touch1 = event.touches[0];
              const touch2 = event.touches[1];
              this.lastTouchDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
              );
            }
          },
          handleTouchZoom(event) {
            if (event.touches.length !== 2) return;

            const touch1 = event.touches[0];
            const touch2 = event.touches[1];
            const currentDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );

            if (this.lastTouchDistance) {
              const scale = currentDistance / this.lastTouchDistance;
              this.handleZoom({
                preventDefault: () => {},
                scale: scale,
                deltaY: undefined, // Add this to indicate it's a pinch zoom
              });
            }

            this.lastTouchDistance = currentDistance;
          },
          handleTreeTouchMove(event) {
            if (event.touches.length === 2) {
              // Handle pinch zoom
              this.handleTouchZoom(event);
              return;
            }

            if (!this.isPanning || event.touches.length !== 1) return;
            const touch = event.touches[0];
            const deltaX = touch.clientX - this.touchStartX;
            const deltaY = touch.clientY - this.touchStartY;

            requestAnimationFrame(() => {
              // Update all skill positions
              this.skills.forEach((skill) => {
                skill.x += deltaX;
                skill.y += deltaY;
              });

              // Update tree position for grid
              this.treePosition = {
                x: this.treePosition.x + deltaX,
                y: this.treePosition.y + deltaY,
              };
            });

            // Force grid recomputation
            if (this.showGlobalGrid) {
              // this.$forceUpdate();
            }

            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
          },

          handleTreeTouchEnd() {
            this.isPanning = false;
            this.touchStartX = null;
            this.touchStartY = null;
            this.lastTouchDistance = null;
          },

          getTooltipPosition(skill) {
            // Get the center position of the skill relative to the viewport
            const skillCenter = skill.x + 30; // 30 is half the skill width
            const viewportCenterOld = window.innerWidth / 2;

            const viewportCenter = this.getAdjustedCoordinates(viewportCenterOld, 0, this.scale).x;
            // If skill is in the right half of the screen, show tooltip on the left
            // Otherwise, show it on the right
            return skillCenter > viewportCenter ? "tooltip-left" : "tooltip-right";
          },

          generateTreeFromPrompt() {
            this.isLoading = true;
            const userPrompt = this.inputText;
            const talentTree = document.querySelector(".talent-tree");

            if (talentTree) {
              talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 1.9)), ${
                talentTree.style.backgroundImage.split("linear-gradient")[1]
              }`;
            }

            // Clear any future history states if we're not at the end
            if (this.historyIndex < this.history.length - 1) {
              this.history = this.history.slice(0, this.historyIndex + 1);
            }

            // Check if we're in local development
            if (window.location.href.includes("127.0.0.1")) {
              // Load test.json instead
              fetch("/src/app/config/test.json")
                .then((response) => response.json())
                .then((data) => {
                  this.handleGeneratedData(data);
                })
                .catch((error) => {
                  this.handleGenerationError(error);
                });
            } else {
              // Original API endpoint logic
              fetch("/generate_tree_from_prompt_old", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ userPrompt: userPrompt }),
              })
                .then((response) => response.json())
                .then((data) => {
                  this.handleGeneratedData(data);
                })
                .catch((error) => {
                  this.handleGenerationError(error);
                });
            }
          },

          // Add these helper methods to handle the response
          handleGeneratedData(data) {
            const talentTree = document.querySelector(".talent-tree");
            this.treePosition = { x: 0, y: 0 };
            this.scale = 1;

            if (talentTree) {
              talentTree.style.filter = "blur(10px)";

              const img = new Image();
              img.onload = () => {
                setTimeout(() => {
                  talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${
                    CONFIG.paths.images.backgrounds
                  }${this.parseBackgroundImage(data["Class Image"])}')`;
                  talentTree.style.filter = "blur(0)";
                }, 100);
              };
              img.src =
                CONFIG.paths.images.backgrounds + this.parseBackgroundImage(data["Class Image"]);
            }

            this.loadSkillsFromData(this.parseSkills(data["Skills"]));
            this.currentBackgroundLink =
              CONFIG.paths.images.backgrounds + this.parseBackgroundImage(data["Class Image"]);
            this.currentName = data["Class Name"];
            this.currentClassDescription = data["Class Description"];
            this.isLoading = false;

            // Save to history after loading
            setTimeout(() => {
              this.saveToHistory();
              this.historyIndex = this.history.length - 1;
            }, 1000);
          },

          handleGenerationError(error) {
            console.error("Error generating skill tree:", error);
            this.isLoading = false;
            this.currentName = "Prompt idea didn't work, please try another.";
            const talentTree = document.querySelector(".talent-tree");
            if (talentTree) {
              talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), ${
                talentTree.style.backgroundImage.split("linear-gradient")[1]
              }`;
              talentTree.style.filter = "blur(0)";
            }
          },

          // Add the parsing functions
          parseSkills(skills) {
            let validImagesString =
              "/axe-hammer-grey.png, /fire-orb.png, /fire-rock.png, /flaming-spear.png, /flaming-staff.png, /golden-arrow.png, /gray-spear.png, /ornate-spear.png, /skull-blue.png, /small-trident.png, /spectral-dagger.png, /water-sword.png";
            validImagesString = validImagesString.replace("/", "");
            const validImagesList = validImagesString.split(", /");
            const defaultImageString = "/fire-rock.png";

            return skills.map((skill) => {
              const skillImage = skill["Skill Image"].replace("/", "");
              if (!validImagesList.includes(skillImage)) {
                skill["Skill Image"] = defaultImageString;
              }
              return skill;
            });
          },

          parseBackgroundImage(backgroundImage) {
            let validImagesString =
              "/grass-ancient.jpg, /desert-academy-ruins.jpg, /purple-spectral-rocks.png";
            validImagesString = validImagesString.replace("/", "");
            const validImagesList = validImagesString.split(", /");
            const defaultImageString = "/grass-ancient.jpg";

            return validImagesList.includes(backgroundImage) ? backgroundImage : defaultImageString;
          },

          saveToHistory() {
            // Don't save if there's no skills (prevents empty initial state)
            if (!this.skills || this.skills.length === 0) {
              return;
            }

            // Remove any future states if we're not at the end of history
            if (this.historyIndex < this.history.length - 1) {
              this.history = this.history.slice(0, this.historyIndex + 1);
            }

            // Create a deep copy of the current state
            const state = {
              skills: JSON.parse(JSON.stringify(this.skills)),
              connections: JSON.parse(JSON.stringify(this.connections)),
              currentName: this.currentName,
              currentBackgroundLink: this.currentBackgroundLink,
              skillIdCounter: this.skillIdCounter,
              timestamp: new Date().toISOString(),
              maxPoints: this.maxPoints,
              currentClassDescription: this.currentClassDescription,
              overlayColor: this.overlayColor,
              overlayOpacity: this.overlayOpacity,
            };

            // Only add state if it's different from the previous state
            const previousState = this.history[this.history.length - 1];
            if (!previousState || JSON.stringify(previousState) !== JSON.stringify(state)) {
              this.history.push(state);

              // Remove oldest state if we exceed maxHistorySize
              if (this.history.length > this.maxHistorySize) {
                this.history.shift();
                this.historyIndex = Math.max(0, this.historyIndex - 1);
              } else {
                this.historyIndex++;
              }
            }
          },

          undo() {
            if (!this.canUndo) {
              console.warn("Undo blocked: canUndo is false");
              return;
            }

            const previousState = this.history[this.historyIndex - 1];
            console.log("previousState", this.history);
            if (!previousState || !previousState.skills || previousState.skills.length === 0) {
              console.warn("Invalid previous state:", previousState);
              return;
            }

            console.log("Restoring to state:", previousState);
            this.historyIndex--;
            this.restoreState(previousState);
          },

          redo() {
            if (this.canRedo) {
              this.historyIndex++;
              this.restoreState(this.history[this.historyIndex]);
            }
          },

          restoreState(state) {
            this.skills = JSON.parse(JSON.stringify(state.skills));
            this.connections = JSON.parse(JSON.stringify(state.connections));
            this.currentName = state.currentName;
            this.currentClassDescription = state.currentClassDescription;
            this.skillIdCounter = state.skillIdCounter;
            this.currentBackgroundLink = state.currentBackgroundLink;
            this.maxPoints = state.maxPoints;
            this.overlayColor = state.overlayColor;
            this.overlayOpacity = state.overlayOpacity;

            // Update background
            this.updateBackground();
          },

          handleEnterKey(event) {
            // Prevent action if already loading or input is empty
            if (this.isLoading || !this.inputText.trim()) {
              return;
            }

            // Prevent default to avoid any potential form submission
            event.preventDefault();

            // Call generate function
            this.generateTreeFromPrompt();
          },

          showGenerateTooltip(event, text) {
            if (!("ontouchstart" in window)) {
              const tooltip = document.createElement("div");
              tooltip.className = "action-btn-tooltip generate-tooltip";
              tooltip.textContent = text;
              event.target.appendChild(tooltip);
            }
          },

          hideGenerateTooltip(event) {
            const tooltip = event.target.querySelector(".generate-tooltip");
            if (tooltip) {
              tooltip.remove();
            }
          },

          openImageSelector() {
            this.showImageSelector = true;
            // Find the current image in allImages
            const currentImage = this.allImages.find((img) => img.src === this.editingSkill.image);
            this.selectedImage = currentImage ? currentImage.id : null;
          },

          selectImage(image) {
            this.selectedImage = image.id;
            // Use the image src directly instead of trying to construct a path
            if (this.editingSkill !== null) {
              this.editingSkill.image = image.src;
            }
          },

          saveImageSelection() {
            console.log("saveImageSelection");
            console.log(this.selectingDefaultImage);
            if (this.selectingDefaultImage) {
              // Set the default image
              this.defaultSkillImage = this.allImages.find(
                (img) => img.id === this.selectedImage
              ).src;
              this.showImageSelector = false;
              this.selectingDefaultImage = false;
              // Optionally save to localStorage for persistence
              localStorage.setItem("defaultSkillImage", this.defaultSkillImage);
              return;
            }

            // Don't modify the image path - use it as is
            this.editingSkill.image = this.editingSkill.image;
            this.showImageSelector = false;

            // Add a class to temporarily disable the tooltip
            const previewEl = document.querySelector(".skill-preview");
            if (previewEl) {
              previewEl.classList.add("hide-tooltip");
            }
          },

          cancelImageSelection() {
            if (this.selectingDefaultImage) {
              this.showImageSelector = false;
              this.selectingDefaultImage = false;
              return;
            }

            this.showImageSelector = false;
            this.selectedImage = null;
          },

          loadTreeById(treeId) {
            fetch(`/api/tree/${treeId}`, {
              headers: {
                Accept: "application/json",
              },
            })
              .then((response) => response.json())
              .then((data) => {
                if (data.error) {
                  console.error("Error loading tree:", data.error);
                  return;
                }

                // Restore the tree state
                this.skills = data.skills;
                this.connections = data.connections;
                this.currentName = data.currentName;
                this.currentBackgroundLink = data.currentBackgroundLink;
                this.skillIdCounter = data.skillIdCounter;

                if (data.currentName) {
                  document.title = `${data.currentName} | Skill Tree Maker`;
                  const metaDescription = document.querySelector('meta[name="description"]');
                  if (metaDescription) {
                    metaDescription.setAttribute(
                      "content",
                      `Check out this ${data.currentName} skill tree created with RPG Skill Tree Maker. You can view or customize it in a drag and drop editor, or download the JSON file.`
                    );
                  }
                }

                // Update background
                const talentTree = document.querySelector(".talent-tree");
                if (talentTree) {
                  talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${this.currentBackgroundLink}')`;
                }

                if (data.prerequisiteMode !== undefined) {
                  console.log("loading settings from save file");
                  this.prerequisiteMode = data.prerequisiteMode;
                  this.overlayColor = data.overlayColor;
                  this.overlayOpacity = data.overlayOpacity;
                  this.skillShape = data.skillShape;
                  this.maxPoints = data.maxPoints;
                  this.config.connection.height = data.connectionWidth;
                  this.showArrows = data.showArrows;
                  this.currentClassDescription = data.currentClassDescription;
                  this.updateBackground();
                  this.updateSkillShape();
                  this.totalStats = this.calculateTotalStats();
                } else {
                  // when scaling fix, all origin got moved to the top left a full screen
                  //tree position doesnt work need tomove skills
                  this.skills.forEach((skill) => {
                    skill.x += window.innerWidth;
                    skill.y += window.innerHeight;
                  });
                }
                if (data.treeUnlockColor !== undefined) {
                  this.treeUnlockColor = data.treeUnlockColor;
                  this.updateTreeUnlockColor();
                }

                console.log("data", data);
                console.log("showStatsSummary", data.showStatsSummary);
                console.log(
                  "data.showStatsSummary !== undefined",
                  data.showStatsSummary !== undefined
                );
                //Todo, find a better way to load all settings from a save file
                // These also need to be added when saving the file
                if (data.showStatsSummary !== undefined) {
                  this.showStatsSummary = data.showStatsSummary;
                  console.log("showStatsSummary2", this.showStatsSummary);
                }
                if (data.showSkillNames !== undefined) {
                  this.showSkillNames = data.showSkillNames;
                }
                if (data.showRequirementsTooltip !== undefined) {
                  this.showRequirementsTooltip = data.showRequirementsTooltip;
                }

                if (data.keepTooltipOpen !== undefined) {
                  this.keepTooltipOpen = data.keepTooltipOpen;
                }

                // When adding new parameters to the skills, the old skills from old files will not have the new parameters.
                // So we need to add them to the old skills.
                // console.log(data);
                if (data.skills[0].size !== undefined) {
                } else {
                  this.skills.forEach((skill) => {
                    skill.size = skill.size || this.skillSizePresets.medium;
                    skill.borderType = skill.borderType || "solid";
                    skill.shape = skill.shape || "round";
                  });
                }

                if (data.skills[0].cost !== undefined) {
                } else {
                  this.skills.forEach((skill) => {
                    skill.cost = skill.cost || 1;
                    skill.prerequisiteModeOverride = skill.prerequisiteModeOverride || "global";
                    skill.exclusiveSkillIds = skill.exclusiveSkillIds || [];
                  });
                }

                this.putTreeInViewport();

                // Mark tree as loaded
                setTimeout(() => {
                  talentTree.classList.add("loaded");
                }, 100);
              })
              .catch((error) => console.error("Error loading tree:", error));
          },

          shareTree() {
            const state = {
              skills: this.skills,
              connections: this.connections,
              currentName: this.currentName,
              currentBackgroundLink: this.currentBackgroundLink,
              skillIdCounter: this.skillIdCounter,
              overlayColor: this.overlayColor,
              overlayOpacity: this.overlayOpacity,
              skillShape: this.skillShape,
              maxPoints: this.maxPoints,
              prerequisiteMode: this.prerequisiteMode,
              connectionWidth: this.config.connection.height,
              showArrows: this.showArrows,
              currentClassDescription: this.currentClassDescription,
              timestamp: new Date().toISOString(),
              id: crypto.randomUUID(),
              showStatsSummary: this.showStatsSummary,
              showSkillNames: this.showSkillNames,
              showRequirementsTooltip: this.showRequirementsTooltip,
              treeUnlockColor: this.treeUnlockColor,
              keepTooltipOpen: this.keepTooltipOpen,
            };

            fetch("/save_tree", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(state),
            })
              .then((response) => response.json())
              .then((data) => {
                const shareableUrl = `${window.location.origin}/tree/${state.id}?mode=view`;

                const modal = document.createElement("div");
                modal.className = "share-modal";
                modal.innerHTML = `
                                                                        <button class="close-btn"></button>
                                                                        <h3>Share Your Skill Tree</h3>
                                                                        <div class="share-link"><a href="${shareableUrl}" target="_blank"> ${shareableUrl}</a></div>
                                                                        <button class="copy-btn" onclick="navigator.clipboard.writeText('${shareableUrl}').then(() => this.textContent = 'Copied!').catch(() => this.textContent = 'Failed to copy')">
                                                                            Copy Link
                                                                        </button>
                                                                        <div style="font-size: 12px; padding: 10px; margin-top: 10px; color: white; font-family: Verdana, sans-serif;"> I do my best to keep these trees saved and available, please consider also downloading a backup tree file by clicking the 'Save Skill Tree' button in the bottom left.</div>
                                                                    `;
                document.body.appendChild(modal);

                // Update click handler to include close button
                const removeModal = (e) => {
                  if (e.target === modal || e.target.classList.contains("close-btn")) {
                    document.body.removeChild(modal);
                    document.removeEventListener("click", removeModal);
                  }
                };
                document.addEventListener("click", removeModal);

                // Add specific handler for close button
                const closeBtn = modal.querySelector(".close-btn");
                closeBtn.addEventListener("click", () => {
                  document.body.removeChild(modal);
                  document.removeEventListener("click", removeModal);
                });
              })
              .catch((error) => console.error("Error sharing tree:", error));
          },
          importFromJson() {
            // Create file input element
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = ".json";

            fileInput.onchange = (e) => {
              const file = e.target.files[0];
              const reader = new FileReader();

              reader.onload = (event) => {
                try {
                  const data = JSON.parse(event.target.result);

                  // Reset tree position and scale
                  this.treePosition = { x: 0, y: 0 };
                  this.scale = 1;

                  // Check if we have the full data state
                  if (data.FullData) {
                    this.showLoadModal = true;
                    this.loadedData = data;

                    //  Do loading from view modal buttons
                  } else {
                    // Fallback to original import logic

                    // Load the skills using existing loadSkillsFromData method
                    this.loadSkillsFromData(data.Skills);

                    // Update background if provided
                    if (data["Class Image"]) {
                      const talentTree = document.querySelector(".talent-tree");
                      if (talentTree) {
                        talentTree.style.filter = "blur(10px)";

                        const img = new Image();
                        img.onload = () => {
                          setTimeout(() => {
                            talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${
                              this.config.paths.images.backgrounds
                            }${this.parseBackgroundImage(data["Class Image"])}')`;
                            talentTree.style.filter = "blur(0)";
                          }, 100);
                        };
                        img.src =
                          this.config.paths.images.backgrounds +
                          this.parseBackgroundImage(data["Class Image"]);
                        this.currentBackgroundLink =
                          this.config.paths.images.backgrounds +
                          this.parseBackgroundImage(data["Class Image"]);
                      }
                    }

                    // Update class name if provided
                    if (data["Class Name"]) {
                      this.currentName = data["Class Name"];
                    }

                    // Update class description if provided
                    if (data["Class Description"]) {
                      this.currentClassDescription = data["Class Description"];
                    }

                    // Save to history after loading
                    setTimeout(() => {
                      this.saveToHistory();
                    }, 1000);
                  }
                } catch (error) {
                  console.error("Error parsing JSON:", error);
                  alert("Invalid JSON file format");
                }
              };

              reader.readAsText(file);
            };

            // Trigger file input click
            fileInput.click();
          },
          updateSkillShape() {
            document.body.classList.remove("square-skills", "diamond-skills", "hexagon-skills");
            if (this.skillShape !== "round") {
              document.body.classList.add(`${this.skillShape}-skills`);
            }
          },
          loadCustomImages() {
            const savedImages = localStorage.getItem("customImages");
            if (savedImages) {
              this.customImages = JSON.parse(savedImages);
            }
          },
          handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              const newImage = {
                id: "custom-" + Date.now(),
                src: e.target.result, // This is the base64 data URL
                name: file.name,
                isDefault: false,
              };

              // Add to custom images array
              this.customImages.push(newImage);

              // Save to localStorage
              localStorage.setItem("customImages", JSON.stringify(this.customImages));

              // Automatically select the newly uploaded image
              this.selectImage(newImage);
            };

            reader.readAsDataURL(file);
          },
          openDiscord() {
            window.open("https://discord.gg/VQy45jAhFP", "_blank");
          },
          openAdditionalWebsite() {
            window.open("https://www.patreon.com/OpenRPGTools", "_blank");
          },
          isViewMode() {
            return this.mode === "view";
          },
          isGameMode() {
            return this.mode === "game";
          },
          isFrozenMode() {
            return this.mode === "frozen";
          },
          handleModeChange() {
            const url = new URL(window.location);
            if (this.mode === "view") {
              url.searchParams.set("mode", "view");
            } else if (this.mode === "game") {
              url.searchParams.set("mode", "game");
            } else if (this.mode === "frozen") {
              url.searchParams.set("mode", "frozen");
            } else {
              url.searchParams.delete("mode");
            }
            window.history.pushState({}, "", url);

            // Toggle appropriate class based on mode
            document.body.classList.remove("view-mode", "game-mode");
            if (this.mode === "view") {
              document.body.classList.add("view-mode");
            } else if (this.mode === "game") {
              document.body.classList.add("game-mode");
            }

            if (this.mode === "view" || this.mode === "game" || this.mode === "frozen") {
              this.showGlobalGrid = false;
              this.skills.forEach((s) => {
                s.showActions = false;
              });
            } else {
              this.showGlobalGrid = true;
            }
          },
          updateBackground() {
            const tree = document.querySelector(".talent-tree");
            if (tree) {
              tree.style.backgroundImage = `linear-gradient(rgba(${parseInt(
                this.overlayColor.slice(1, 3),
                16
              )}, ${parseInt(this.overlayColor.slice(3, 5), 16)}, ${parseInt(
                this.overlayColor.slice(5, 7),
                16
              )}, ${this.overlayOpacity / 100}), rgba(${parseInt(
                this.overlayColor.slice(1, 3),
                16
              )}, ${parseInt(this.overlayColor.slice(3, 5), 16)}, ${parseInt(
                this.overlayColor.slice(5, 7),
                16
              )}, ${this.overlayOpacity / 100})), url('${this.currentBackgroundLink}')`;
            }
          },
          updateTreeUnlockColor() {
            // console.log("selection color", this.treeUnlockColor);
            // const activeConnections = document.querySelectorAll(
            //   ".connection.active .connection-after"
            // );
            // activeConnections.forEach((conn) => {
            //   conn.style.borderLeftColor = this.treeUnlockColor;
            // });

            // const activeConnectionBodies = document.querySelectorAll(".connection.active");
            // activeConnectionBodies.forEach((conn) => {
            //   conn.style.background = this.treeUnlockColor;
            //   conn.style.boxShadow = `0 0 5px ${this.treeUnlockColor}`;
            // });

            // const selectedSkills = document.querySelectorAll(".skill.selected");
            // selectedSkills.forEach((skill) => {
            //   skill.style.borderColor = this.treeUnlockColor;
            //   skill.style.boxShadow = `0 0 10px ${this.treeUnlockColor}`;
            // });

            // const skilledSkills = document.querySelectorAll(".skill.skilled");
            // skilledSkills.forEach((skill) => {
            //   skill.style.border = `2px solid ${this.treeUnlockColor}`;
            //   skill.style.boxShadow = `0 0 10px ${this.treeUnlockColor}`;
            // });

            // Update CSS variable for hover effects
            document.documentElement.style.setProperty("--tree-unlock-color", this.treeUnlockColor);

            // const tree = document.querySelector(".talent-tree");
            // if (tree) {
            //   tree.style.backgroundImage = `linear-gradient(rgba(${parseInt(
            //     this.overlayColor.slice(1, 3),
            //     16
            //   )}, ${parseInt(this.overlayColor.slice(3, 5), 16)}, ${parseInt(
            //     this.overlayColor.slice(5, 7),
            //     16
            //   )}, ${this.selectionOpacity / 100}), rgba(${parseInt(
            //     this.overlayColor.slice(1, 3),
            //     16
            //   )}, ${parseInt(this.selectionColor.slice(3, 5), 16)}, ${parseInt(
            //     this.selectionColor.slice(5, 7),
            //     16
            //   )}, ${this.selectionOpacity / 100})), url('${this.currentBackgroundLink}')`;
            // }
          },
          editConnection(connection) {
            if (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) return;
            this.selectedConnection = connection;
            this.editingConnection = true;
          },
          cancelEditConnection() {
            this.editingConnection = false;
            this.selectedConnection = null;
          },
          saveEditConnection() {
            this.editingConnection = false;
            this.selectedConnection = null;
            this.saveToHistory();
          },
          startDragControlPoint(event, connection) {
            if (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) return;

            this.draggedConnection = connection;
            event.preventDefault();

            document.addEventListener("mousemove", this.dragControlPoint);
            document.addEventListener("mouseup", this.stopDragControlPoint);
          },

          dragControlPoint(event) {
            if (!this.draggedConnection) return;

            const rect = this.$el.querySelector(".talent-tree").getBoundingClientRect();
            const x = (event.clientX - rect.left) / this.scale;
            const y = (event.clientY - rect.top) / this.scale;

            this.draggedConnection.controlPoint.x = x;
            this.draggedConnection.controlPoint.y = y;
          },

          stopDragControlPoint() {
            this.draggedConnection = null;
            document.removeEventListener("mousemove", this.dragControlPoint);
            document.removeEventListener("mouseup", this.stopDragControlPoint);
            this.saveToHistory();
          },

          removeConnection(connection) {
            if (this.isViewMode() || this.isGameMode() || this.isFrozenMode()) return; // Don't remove connections in view mode
            this.connections = this.connections.filter((c) => c.id !== connection.id);
            this.saveToHistory();
            if (this.editingConnection) {
              this.editingConnection = false;
              this.selectedConnection = null;
            }
          },

          dragStart(e, fromIndex) {
            e.dataTransfer.setData("index", fromIndex);
          },

          drop(e, toIndex) {
            const fromIndex = e.dataTransfer.getData("index");
            const resources = [...this.editingSkill.resources];
            const [resource] = resources.splice(fromIndex, 1);
            resources.splice(toIndex, 0, resource);
            this.editingSkill.resources = resources;
          },
          snapToGrid(x, y, skillSize = 60) {
            // let skillSize = this.editingSkill.size;
            const size = parseInt(this.gridSize) / 2; // Use half the grid size for center points
            const offsetX = this.treePosition.x % (size * 2);
            const offsetY = this.treePosition.y % (size * 2);

            const gridOffset = size / 2;
            // Adjust position by grid size and offset, then subtract skill offset
            return {
              x: Math.round((x - offsetX + gridOffset / 2) / size) * size + offsetX - skillSize / 2,
              y: Math.round((y - offsetY + gridOffset / 2) / size) * size + offsetY - skillSize / 2,
            };
          },
          // Helper function to check if a prerequisite skill requirement is satisfied
          // This accounts for mutually exclusive skills - if any skill in a mutually exclusive group has points,
          // the requirement is considered satisfied
          isPrerequisiteSatisfied(prereqSkill) {
            // Direct satisfaction - the skill itself has points
            if (prereqSkill && prereqSkill.currentPoints > 0) {
              return true;
            }

            // Check if any mutually exclusive skills have points
            if (
              prereqSkill &&
              prereqSkill.exclusiveSkillIds &&
              prereqSkill.exclusiveSkillIds.length > 0
            ) {
              return prereqSkill.exclusiveSkillIds.some((exclusiveId) => {
                const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                return exclusiveSkill && exclusiveSkill.currentPoints > 0;
              });
            }

            return false;
          },
          canAddPoint(skill, option = "show warning") {
            // Check if adding a point would exceed max points
            if (this.totalPointsSpent >= this.maxPoints) {
              return false;
            }

            // Check mutual exclusivity
            if (skill.exclusiveSkillIds && skill.exclusiveSkillIds.length > 0) {
              const hasExclusiveSkillActive = skill.exclusiveSkillIds.some((exclusiveId) => {
                const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                return exclusiveSkill && exclusiveSkill.currentPoints > 0;
              });

              if (hasExclusiveSkillActive) {
                if (option === "show warning") {
                  const activeExclusiveSkills = skill.exclusiveSkillIds
                    .filter((exclusiveId) => {
                      const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                      return exclusiveSkill && exclusiveSkill.currentPoints > 0;
                    })
                    .map((exclusiveId) => {
                      const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                      return exclusiveSkill.name;
                    })
                    .join(", ");

                  const toast = document.createElement("div");
                  toast.className = "toast-notification";
                  toast.textContent = `Cannot unlock ${skill.name} - conflicts with: ${activeExclusiveSkills}`;
                  document.body.appendChild(toast);

                  toast.offsetHeight;
                  toast.classList.add("show");

                  setTimeout(() => {
                    toast.classList.remove("show");
                    setTimeout(() => toast.remove(), 300);
                  }, 3000);
                }
                return false;
              }
            }

            // Check if required points are met
            if (skill.requiredPoints && this.totalPointsSpent < skill.requiredPoints) {
              // Create and show toast notification
              if (option === "show warning") {
                const toast = document.createElement("div");
                toast.className = "toast-notification";
                toast.textContent = `${skill.name} requires ${skill.requiredPoints} points spent. Current: ${this.totalPointsSpent}`;
                document.body.appendChild(toast);

                // Trigger reflow to ensure animation plays
                toast.offsetHeight;
                toast.classList.add("show");

                // Remove toast after animation
                setTimeout(() => {
                  toast.classList.remove("show");
                  setTimeout(() => toast.remove(), 300); // Remove after fade out
                }, 2000);
              }
              return false;
            }

            // Check if skill has required points
            if (skill.damage) {
              // Using old damage field for required points
              const requiredPoints = parseInt(skill.damage);
              if (!isNaN(requiredPoints) && this.totalPointsSpent < requiredPoints) {
                return false;
              }
            }

            // Check prerequisites (incoming connections)
            const incomingConnections = this.connections.filter((conn) => conn.to === skill.id);
            if (incomingConnections.length > 0) {
              if (this.prerequisiteMode === "none") {
                return true;
              } else if (this.prerequisiteMode === "all") {
                // Check if ALL prerequisite skills are unlocked (including through mutual exclusivity)
                const allPrereqsUnlocked = incomingConnections.every((conn) => {
                  const prereqSkill = this.skills.find((s) => s.id === conn.from);
                  return this.isPrerequisiteSatisfied(prereqSkill);
                });

                if (!allPrereqsUnlocked) {
                  if (option === "show warning") {
                    // Show toast notification for prerequisite requirement
                    const toast = document.createElement("div");
                    toast.className = "toast-notification";

                    // Get list of missing prerequisites
                    const missingPrereqs = incomingConnections
                      .filter((conn) => {
                        const prereqSkill = this.skills.find((s) => s.id === conn.from);
                        return !this.isPrerequisiteSatisfied(prereqSkill);
                      })
                      .map((conn) => {
                        const prereqSkill = this.skills.find((s) => s.id === conn.from);
                        return prereqSkill?.name || "Unknown";
                      })
                      .join(", ");

                    toast.textContent = `${skill.name} requires: ${missingPrereqs} to unlock`;
                    document.body.appendChild(toast);

                    toast.offsetHeight;
                    toast.classList.add("show");

                    setTimeout(() => {
                      toast.classList.remove("show");
                      setTimeout(() => toast.remove(), 300);
                    }, 3000);
                  }
                  return false;
                }
              } else {
                // 'one' mode - Check if at least one prerequisite skill is unlocked (including through mutual exclusivity)
                const hasUnlockedPrereq = incomingConnections.some((conn) => {
                  const prereqSkill = this.skills.find((s) => s.id === conn.from);
                  return this.isPrerequisiteSatisfied(prereqSkill);
                });

                if (!hasUnlockedPrereq) {
                  if (option === "show warning") {
                    const prereqSkills = incomingConnections
                      .map((conn) => {
                        const prereqSkill = this.skills.find((s) => s.id === conn.from);
                        return prereqSkill?.name || "Unknown";
                      })
                      .join(" or ");

                    // Show toast notification for prerequisite requirement
                    const toast = document.createElement("div");
                    toast.className = "toast-notification";
                    toast.textContent = `${skill.name} requires: ${prereqSkills} to unlock`;

                    document.body.appendChild(toast);

                    toast.offsetHeight;
                    toast.classList.add("show");

                    setTimeout(() => {
                      toast.classList.remove("show");
                      setTimeout(() => toast.remove(), 300);
                    }, 3000);
                  }
                  return false;
                }
              }
            }

            return true;
          },
          // canAddPoint(skill, option = "show warning") {
          //   // Check if adding a point would exceed max points
          //   if (this.totalPointsSpent >= this.maxPoints) {
          //     return false;
          //   }

          //   // Check mutual exclusivity
          //   if (skill.exclusiveSkillIds && skill.exclusiveSkillIds.length > 0) {
          //     const hasExclusiveSkillActive = skill.exclusiveSkillIds.some((exclusiveId) => {
          //       const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
          //       return exclusiveSkill && exclusiveSkill.currentPoints > 0;
          //     });

          //     if (hasExclusiveSkillActive) {
          //       if (option === "show warning") {
          //         const activeExclusiveSkills = skill.exclusiveSkillIds
          //           .filter((exclusiveId) => {
          //             const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
          //             return exclusiveSkill && exclusiveSkill.currentPoints > 0;
          //           })
          //           .map((exclusiveId) => {
          //             const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
          //             return exclusiveSkill.name;
          //           })
          //           .join(", ");

          //         const toast = document.createElement("div");
          //         toast.className = "toast-notification";
          //         toast.textContent = `Cannot unlock ${skill.name} - conflicts with: ${activeExclusiveSkills}`;
          //         document.body.appendChild(toast);

          //         toast.offsetHeight;
          //         toast.classList.add("show");

          //         setTimeout(() => {
          //           toast.classList.remove("show");
          //           setTimeout(() => toast.remove(), 300);
          //         }, 3000);
          //       }
          //       return false;
          //     }
          //   }

          //   // Check if required points are met
          //   if (skill.requiredPoints && this.totalPointsSpent < skill.requiredPoints) {
          //     // Create and show toast notification
          //     if (option === "show warning") {
          //       const toast = document.createElement("div");
          //       toast.className = "toast-notification";
          //       toast.textContent = `${skill.name} requires ${skill.requiredPoints} points spent. Current: ${this.totalPointsSpent}`;
          //       document.body.appendChild(toast);

          //       // Trigger reflow to ensure animation plays
          //       toast.offsetHeight;
          //       toast.classList.add("show");

          //       // Remove toast after animation
          //       setTimeout(() => {
          //         toast.classList.remove("show");
          //         setTimeout(() => toast.remove(), 300); // Remove after fade out
          //       }, 2000);
          //     }
          //     return false;
          //   }

          //   // Check if skill has required points
          //   if (skill.damage) {
          //     // Using old damage field for required points
          //     const requiredPoints = parseInt(skill.damage);
          //     if (!isNaN(requiredPoints) && this.totalPointsSpent < requiredPoints) {
          //       return false;
          //     }
          //   }
          //   // Check prerequisites (incoming connections)
          //   const incomingConnections = this.connections.filter((conn) => conn.to === skill.id);
          //   if (incomingConnections.length > 0) {
          //     if (this.prerequisiteMode === "none") {
          //       return true;
          //     } else if (this.prerequisiteMode === "all") {
          //       // Check if ALL prerequisite skills are unlocked
          //       const allPrereqsUnlocked = incomingConnections.every((conn) => {
          //         const prereqSkill = this.skills.find((s) => s.id === conn.from);
          //         return prereqSkill && prereqSkill.currentPoints > 0;
          //       });

          //       if (!allPrereqsUnlocked) {
          //         if (option === "show warning") {
          //           // Show toast notification for prerequisite requirement
          //           const toast = document.createElement("div");
          //           toast.className = "toast-notification";

          //           // Get list of missing prerequisites
          //           const missingPrereqs = incomingConnections
          //             .filter((conn) => {
          //               const prereqSkill = this.skills.find((s) => s.id === conn.from);
          //               return !prereqSkill || prereqSkill.currentPoints === 0;
          //             })
          //             .map((conn) => {
          //               const prereqSkill = this.skills.find((s) => s.id === conn.from);
          //               return prereqSkill.name;
          //             })
          //             .join(", ");

          //           toast.textContent = `${skill.name} requires: ${missingPrereqs} to unlock`;
          //           document.body.appendChild(toast);

          //           toast.offsetHeight;
          //           toast.classList.add("show");

          //           setTimeout(() => {
          //             toast.classList.remove("show");
          //             setTimeout(() => toast.remove(), 300);
          //           }, 3000);
          //         }
          //         return false;
          //       }
          //     } else {
          //       // 'one'
          //       // Check if at least one prerequisite skill is unlocked
          //       const hasUnlockedPrereq = incomingConnections.some((conn) => {
          //         const prereqSkill = this.skills.find((s) => s.id === conn.from);
          //         return prereqSkill && prereqSkill.currentPoints > 0;
          //       });

          //       if (!hasUnlockedPrereq) {
          //         if (option === "show warning") {
          //           const prereqSkills = incomingConnections
          //             .map((conn) => {
          //               const prereqSkill = this.skills.find((s) => s.id === conn.from);
          //               return prereqSkill.name;
          //             })
          //             .join(" or ");

          //           // Show toast notification for prerequisite requirement
          //           const toast = document.createElement("div");
          //           toast.className = "toast-notification";
          //           toast.textContent = `${skill.name} requires: ${prereqSkills} to unlock`;

          //           document.body.appendChild(toast);

          //           toast.offsetHeight;
          //           toast.classList.add("show");

          //           setTimeout(() => {
          //             toast.classList.remove("show");
          //             setTimeout(() => toast.remove(), 300);
          //           }, 3000);
          //         }
          //         return false;
          //       }
          //     }
          //   }

          //   return true;
          // },
          toggleSkillSelection(skill) {
            if (this.isViewMode()) return;
            //  if n
            if (!skill.showActions) {
              skill.showActions = true;
              this.selectedSkills.push(skill);
            } else {
              skill.showActions = false;
              const index = this.selectedSkills.indexOf(skill.id);
              this.selectedSkills.splice(index, 1);
            }
            // if (index === -1) {

            // } else {
            // }

            console.log("selectedSkills", this.selectedSkills);
          },
          putTreeInViewport() {
            const bounds = this.skills.reduce(
              (acc, skill) => {
                return {
                  minX: Math.min(acc.minX, skill.x),
                  minY: Math.min(acc.minY, skill.y),
                  maxX: Math.max(acc.maxX, skill.x + 60), // Add skill width
                  maxY: Math.max(acc.maxY, skill.y + 60), // Add skill height
                };
              },
              {
                minX: Infinity,
                minY: Infinity,
                maxX: -Infinity,
                maxY: -Infinity,
              }
            );

            // Calculate tree dimensions using snapped bounds
            const treeWidth = bounds.maxX - bounds.minX;
            const treeHeight = bounds.maxY - bounds.minY;
            console.log("treeWidth", treeWidth);

            // Calculate viewport dimensions accounting for zoom container
            const viewportWidth = window.innerWidth * 2; // Account for zoom-tree width being 200%
            const viewportHeight = window.innerHeight * 2; // Account for zoom-tree height being 200%

            // Calculate center position
            const centerX = (viewportWidth - treeWidth) / 2;
            const centerY = (viewportHeight - treeHeight) / 2;
            // Snap center position to grid
            const snappedCenterX =
              Math.round(centerX / (this.gridSize / 2)) * (this.gridSize / 2) - 30;
            const snappedCenterY =
              Math.round(centerY / (this.gridSize / 2)) * (this.gridSize / 2) - 30; // +30 works exactly on desktop, but doesn't matach grid on mobile. - 30 works for grid both desktop and mobule, just jumps up on desktop

            // console.log("centerX", centerX);
            // console.log("centerY", centerY);

            // console.log("bounds.minX", bounds.minX);
            // console.log("bounds.minY", bounds.minY);
            // Get adjusted coordinates for the viewport center

            // Calculate required offset to center the tree
            const offsetX = snappedCenterX - bounds.minX;
            const offsetY = snappedCenterY - bounds.minY;

            // Adjust all skill positions
            this.skills.forEach((skill) => {
              skill.x += offsetX;
              skill.y += offsetY;
            });

            // Get top-left most node position
            //           const topLeftNode = this.skills.reduce(
            //             (topLeft, skill) => {
            //               if (skill.x < topLeft.x || (skill.x === topLeft.x && skill.y < topLeft.y)) {
            //                 return { x: skill.x, y: skill.y };
            //               }
            //               return topLeft;
            //             },
            //             { x: Infinity, y: Infinity }
            //           );

            //           let adjustedTopLeft = this.getAdjustedCoordinates(
            //             topLeftNode.x,
            //             topLeftNode.y,
            //             this.scale
            //           );
            //           adjustedTopLeft = { x: this.skills[0].x, y: this.skills[0].y };
            //           adjustedTopLeft.x = topLeftNode.x / 2 - this.gridSize / 2;
            //           adjustedTopLeft.y = topLeftNode.y / 2 - this.gridSize / 2;

            //           if (document.querySelector(".debug-dot") === null) {
            //             const dot = document.createElement("div");
            //             dot.className = "debug-dot";
            //             dot.style.cssText = `
            //   position: absolute;
            //   width: 10px;
            //   height: 10px;
            //   background-color: red;
            //   border-radius: 50%;
            //   z-index: 9999;
            //   pointer-events: none;
            //   left: ${adjustedTopLeft.x}px;
            //   top: ${adjustedTopLeft.y}px;

            // `;
            //             console.log("dot", dot);
            //             document.querySelector(".talent-tree").appendChild(dot);
            //           } else {
            //             document.querySelector(".debug-dot").style.top = `${adjustedTopLeft.y}px`;
            //             document.querySelector(".debug-dot").style.left = `${adjustedTopLeft.x}px`;
            //           }

            // Reset zoom and position
            this.scale = 1;
            this.treePosition = { x: 0, y: 0 };

            // Force update of zoom container
            const container = document.querySelector(".zoom-tree");
            if (container) {
              container.style.transform = `translate(-25%, -25%) scale(${this.scale})`;
            }
          },
          loadTree(mode) {
            if (mode === "overwrite") {
              // Import using full data state
              Object.keys(this.loadedData.FullData).forEach((key) => {
                if (key === "loadedData") {
                  return;
                }
                // console.log("loading for key", key);
                this[key] = this.loadedData.FullData[key];
                this.totalStats = this.calculateTotalStats();
                this.historyIndex = 0;
              });
              // console.log("prerequisiteMode", this.loadedData.FullData.prerequisiteMode);
              if (this.loadedData.FullData.prerequisiteMode !== undefined) {
              } else {
                this.skills.forEach((skill) => {
                  skill.x += window.innerWidth / 2;
                  skill.y += window.innerHeight / 2;
                });
              }

              // console.log(this.loadedData.FullData.skills[0]);
              if (this.loadedData.FullData.skills[0].size !== undefined) {
              } else {
                this.skills.forEach((skill) => {
                  skill.size = skill.size || this.skillSizePresets.medium;
                  skill.borderType = skill.borderType || "solid";
                  skill.shape = skill.shape || "round";
                });
              }
              if (this.loadedData.FullData.skills[0].cost !== undefined) {
              } else {
                this.skills.forEach((skill) => {
                  skill.cost = skill.cost || 1;
                  skill.prerequisiteModeOverride = skill.prerequisiteModeOverride || "global";
                  skill.exclusiveSkillIds = skill.exclusiveSkillIds || [];
                });
              }

              this.treeEl = document.querySelector(".talent-tree");

              // console.log("not adjusting visiblity");
              this.putTreeInViewport();
              // Find bounding box of all skills
              // const bounds = this.skills.reduce(
              //   (acc, skill) => {
              //     return {
              //       minX: Math.min(acc.minX, skill.x),
              //       minY: Math.min(acc.minY, skill.y),
              //       maxX: Math.max(acc.maxX, skill.x + 60), // Add skill width
              //       maxY: Math.max(acc.maxY, skill.y + 60), // Add skill height
              //     };
              //   },
              //   {
              //     minX: Infinity,
              //     minY: Infinity,
              //     maxX: -Infinity,
              //     maxY: -Infinity,
              //   }
              // );

              // // Calculate viewport adjustments based on current zoom
              // const viewportWidth = window.innerWidth;
              // const viewportHeight = window.innerHeight;

              // // Position skills to be visible in viewport
              // const offsetX = bounds.minX - viewportWidth * 0.7; // Add 10% padding
              // const offsetY = bounds.minY - viewportHeight * 0.7;

              // // Adjust all skill positions
              // this.skills.forEach((skill) => {
              //   skill.x -= offsetX;
              //   skill.y -= offsetY;
              // });

              // this.handleZoom();

              this.updateBackground();
              if (this.treeUnlockColor !== undefined) {
                this.updateTreeUnlockColor();
              }
            } else if (mode === "merge") {
              this.deselectAllSkills();
              const offset = 0; // Increased offset for better visibility
              const idMap = {};

              // Handle both full data export and regular skill data formats
              const skillsToMerge = this.loadedData.FullData?.skills || this.loadedData.Skills;

              // First pass: Create all skills with new IDs and positions
              skillsToMerge.forEach((skillData) => {
                const newId = ++this.skillIdCounter;

                // Handle different data formats
                const skill = this.loadedData.FullData?.skills
                  ? {
                      ...skillData,
                      id: newId,
                      x: skillData.x + offset,
                      y: skillData.y + offset,
                      showActions: false,
                      shouldAnimate: true,
                    }
                  : {
                      id: newId,
                      name: skillData["Skill Name"],
                      x:
                        this.config.grid.startX +
                        parseInt(skillData["Skill Position"].match(/\((\d+)/)[1]) *
                          this.config.grid.spacing +
                        offset,
                      y:
                        this.config.grid.startY +
                        parseInt(skillData["Skill Position"].match(/,\s*(\d+)/)[1]) *
                          this.config.grid.spacing +
                        offset,
                      description: skillData["Skill Description"],
                      maxPoints: skillData["Skill Max Points"] || this.defaultMaxPoints,
                      currentPoints: skillData["Skill Current Points"] || 0,
                      image: `${this.config.paths.images.skills}${skillData["Skill Image"]}`,
                      showActions: false,
                      shouldAnimate: true,
                      resources: skillData["Skill Resources"] || [],
                      size: skillData["size"] || this.skillSizePresets.medium, // Default to medium size
                      borderType: skillData["borderType"] || "solid", // Default border style
                      shape: skillData["shape"] || "round",
                      cost: skillData["cost"] || 1,
                      prerequisiteModeOverride: skillData["prerequisiteModeOverride"] || "global", // "global", "one", "all"
                      exclusiveSkillIds: skillData["exclusiveSkillIds"] || [], // ids of skills that are exclusive to this skill, used in connections
                    };

                // Store the mapping of old ID to new ID
                idMap[skillData.id || skillData["Skill Name"]] = newId;
                this.skills.push(skill);
              });

              if (this.loadedData.FullData.skills[0].size !== undefined) {
              } else {
                this.skills.forEach((skill) => {
                  skill.size = skill.size || this.skillSizePresets.medium;
                  skill.borderType = skill.borderType || "solid";
                  skill.shape = skill.shape || "round";
                });
              }
              if (this.loadedData.FullData.skills[0].cost !== undefined) {
              } else {
                this.skills.forEach((skill) => {
                  skill.cost = skill.cost || 1;
                  skill.prerequisiteModeOverride = skill.prerequisiteModeOverride || "global";
                  skill.exclusiveSkillIds = skill.exclusiveSkillIds || [];
                });
              }

              // Second pass: Create connections with updated IDs
              if (this.loadedData.FullData?.connections) {
                // Handle full data export connections
                this.loadedData.FullData.connections.forEach((conn) => {
                  this.connections.push({
                    id: `${idMap[conn.from]}-${idMap[conn.to]}`,
                    from: idMap[conn.from],
                    to: idMap[conn.to],
                    hasControlPoint: false,
                    controlPoint: { x: 0, y: 0 },
                    mutuallyExclusive: false,
                    dotted: false,
                  });
                });
              } else {
                // Handle regular skill data connections
                skillsToMerge.forEach((skillData) => {
                  if (skillData["Skill Prerequisite"] && skillData["Skill Prerequisite"] !== "-") {
                    const prereqName = skillData["Skill Prerequisite"].split(" (")[0];
                    const fromId = idMap[prereqName];
                    const toId = idMap[skillData["Skill Name"]];

                    if (fromId && toId) {
                      this.connections.push({
                        id: `${fromId}-${toId}`,
                        from: fromId,
                        to: toId,
                        hasControlPoint: false,
                        controlPoint: { x: 0, y: 0 },
                        mutuallyExclusive: false,
                        dotted: false,
                      });
                    }
                  }
                });
              }

              // Trigger animations for new skills
              setTimeout(() => {
                this.skills.forEach((skill) => {
                  if (skill.id > this.skillIdCounter - skillsToMerge.length) {
                    skill.shouldAnimate = true;
                  }
                });
              }, 100);
              this.totalStats = this.calculateTotalStats();
            }

            this.showLoadModal = false;

            setTimeout(() => {
              this.saveToHistory();
              this.loadedData = null;
            }, 1000);
          },
          handleBackgroundUpload(event) {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const imageData = {
                  id: `bg_${Date.now()}`,
                  src: e.target.result,
                  name: file.name,
                  type: "background",
                };

                // Update recent backgrounds
                this.recentBackgrounds.unshift(imageData);
                // Keep only the 3 most recent
                this.recentBackgrounds = this.recentBackgrounds.slice(0, 3);
                // Save to localStorage
                localStorage.setItem("recentBackgrounds", JSON.stringify(this.recentBackgrounds));

                // Save to localStorage
                const customImages = JSON.parse(localStorage.getItem("customImages") || "[]");
                customImages.push(imageData);
                localStorage.setItem("customImages", JSON.stringify(customImages));

                // Update background
                this.currentBackgroundLink = imageData.src;
                this.updateBackground();
              };
              reader.readAsDataURL(file);
            }
          },

          // updateBackground() {
          //     const talentTree = document.querySelector('.talent-tree');
          //     if (talentTree && this.currentBackgroundLink) {
          //         talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, ${this.overlayOpacity / 100}), rgba(0, 0, 0, ${this.overlayOpacity / 100})), url('${this.currentBackgroundLink}')`;
          //     }
          // },

          // Add these new methods
          handleSelection(eventOld) {
            // Check if we're interacting with a skill or other UI element
            if (!eventOld.target) {
              // event.target.classList is undefined if dragged off screen. maybe use this to shift the view
              return;
            }
            let adjustedCoordinates = this.getAdjustedCoordinates(
              eventOld.clientX,
              eventOld.clientY,
              this.scale
            );
            let event = {
              clientX: adjustedCoordinates.x,
              clientY: adjustedCoordinates.y,
              offsetX: adjustedCoordinates.x,
              offsetY: adjustedCoordinates.y,
            };

            const moveThreshold = 5; // pixels
            const deltaX = event.offsetX - this.initialClick.x;
            const deltaY = event.offsetY - this.initialClick.y;

            if (Math.abs(deltaX) > moveThreshold || Math.abs(deltaY) > moveThreshold) {
              // Create selection box on first movement
              this.selectionBox = {
                x: this.initialClick.x,
                y: this.initialClick.y,
                width: 0,
                height: 0,
              };
            }

            if (this.selectionBox) {
              this.selectionBox.width = event.offsetX - this.selectionBox.x;
              this.selectionBox.height = event.offsetY - this.selectionBox.y;

              // Select skills within box
              // Select skills within box and set showActions
              this.selectedSkills = this.skills.filter((skill) => {
                const box = {
                  left: Math.min(
                    this.selectionBox.x,
                    this.selectionBox.x + this.selectionBox.width
                  ),
                  right: Math.max(
                    this.selectionBox.x,
                    this.selectionBox.x + this.selectionBox.width
                  ),
                  top: Math.min(
                    this.selectionBox.y,
                    this.selectionBox.y + this.selectionBox.height
                  ),
                  bottom: Math.max(
                    this.selectionBox.y,
                    this.selectionBox.y + this.selectionBox.height
                  ),
                };
                const isSelected =
                  skill.x + 30 >= box.left &&
                  skill.x + 30 <= box.right &&
                  skill.y + 30 >= box.top &&
                  skill.y + 30 <= box.bottom;

                skill.showActions = isSelected;
                return isSelected;
              });
            }
          },

          stopSelection() {
            if (this.selectionBox) {
              setTimeout(() => {
                this.selectionBox = null;
              }, 100);
            }

            document.removeEventListener("mousemove", this.handleSelection);
            document.removeEventListener("mouseup", this.stopSelection);
            // Keep the selection but remove the box
          },
          deselectAllSkills() {
            // Clear all existing selections and action menus
            this.selectedSkills = [];
            this.skills.forEach((s) => {
              s.showActions = false;
              s.showTooltip = false;
            });
            //hide skill description preview
          },
          isTextInputActive() {
            const activeElement = document.activeElement;

            // Check if the active element is a text input field
            return (
              activeElement &&
              ((activeElement.tagName === "INPUT" &&
                ["text", "password", "email", "number", "search", "tel", "url"].includes(
                  activeElement.type
                )) ||
                activeElement.tagName === "TEXTAREA" ||
                activeElement.contentEditable === "true")
            );
          },

          copy() {
            // It seems like this.selectedSkills cannot be accessed here.
            // Possibly due to a scope issue.

            const selectedSkills = this.skills.filter((skill) => skill.showActions);

            if (selectedSkills.length === 0) {
              return;
            } else {
              this.clipboard = selectedSkills;
            }

            // console.log("Copied nodes:", this.clipboard);
          },

          paste() {
            if (this.isTextInputActive()) {
              return;
            }
            this.deselectAllSkills();

            // append "copy" to the skill name
            // adjust positions by a small offset so they are not perfectly overlapping
            // add nodes from clipboard to the state
            // update the selected nodes to be the newly pasted ones

            if (this.clipboard.length === 0) {
              return;
            }

            // Deep copy the clipboard nodes
            const copiedNodes = JSON.parse(JSON.stringify(this.clipboard));

            // Calculate grid-based offset
            const gridOffset = this.showGlobalGrid ? parseInt(this.gridSize) : 120; // Use grid size if enabled, otherwise default to 120px

            // Update copied nodes
            copiedNodes.forEach((node) => {
              node.id = ++this.skillIdCounter;
              node.x += gridOffset / 2;
              node.y += gridOffset / 2;
              node.showActions = true;
              node.shouldAnimate = true;
              node.name += " copy";
            });

            // Add copied nodes to the state
            this.selectedSkills = copiedNodes;
            this.skills.push(...copiedNodes);
            this.saveToHistory();
          },
          handleResize() {
            this.putTreeInViewport();

            // Force recomputation of grid lines
            // this.gridSize = window.innerWidth <= 768 ? 80 : 120;

            const zoomTree = document.querySelector(".zoom-tree");
            if (zoomTree) {
              zoomTree.style.width = `${window.innerWidth * 2}px`;
              zoomTree.style.height = `${window.innerHeight * 2}px`;
            }

            //this keeps it in place but anchors it from grid
            // const oldWidth = this.prevWindowWidth || window.innerWidth;
            // const oldHeight = this.prevWindowHeight || window.innerHeight;

            // // Calculate the change in dimensions
            // const widthDiff = window.innerWidth - oldWidth;
            // const heightDiff = window.innerHeight - oldHeight;
            // // Adjust all skill positions based on window size change
            // this.skills.forEach((skill) => {
            //   skill.x += widthDiff; // Move half the width difference
            //   skill.y += heightDiff; // Move half the height difference
            // });

            // // Store new dimensions for next resize
            // this.prevWindowWidth = window.innerWidth;
            // this.prevWindowHeight = window.innerHeight;

            if (this.showGlobalGrid) {
              // Update the tree position slightly to force reactivity
              this.treePosition = {
                x: this.treePosition.x,
                y: this.treePosition.y,
              };

              // Force Vue to recompute the grid lines
              // this.$nextTick(() => {
              // this.$forceUpdate();
              // });
            }
          },
          toggleGenerateControls() {
            this.showGenerateControls = !this.showGenerateControls;
          },
          selectAllSkills() {
            if (this.isViewMode()) return;

            // Clear existing selection
            this.deselectAllSkills();

            // Select all skills
            this.skills.forEach((skill) => {
              skill.showActions = true;
              this.selectedSkills.push(skill);
            });
          },
          incrementRank(editingSkill) {
            if (!this.editingSkill.rank) {
              this.editingSkill.rank = 1;
            }
            if (this.editingSkill.rank < editingSkill.maxPoints) {
              this.editingSkill.rank++;
            }
          },

          decrementRank() {
            if (this.editingSkill.rank > 1) {
              this.editingSkill.rank--;
            }
          },
          calculateRankValue(value, rank) {
            // Extract the number and check for percentage
            const hasPercent = value.includes("%");
            const numberMatch = value.match(/\d+(\.\d+)?/);

            if (!numberMatch) return value;

            const baseNumber = parseFloat(numberMatch[0]);
            const multipliedValue = baseNumber * rank;

            // Format the result
            const formattedValue = Number.isInteger(multipliedValue)
              ? multipliedValue.toString()
              : multipliedValue.toFixed(1);

            return hasPercent ? formattedValue + "%" : formattedValue;
          },
          calculateTotalStats() {
            // console.log("calculating total stats");
            return this.skills.reduce((totals, skill) => {
              if (skill.currentPoints > 0 && skill.resources) {
                skill.resources.forEach(({ name, value, color }) => {
                  const parsedStat = this.parseStatValue(value, skill.currentPoints);
                  // console.log(
                  //   "calculating total stats",
                  //   name,
                  //   value,
                  //   skill.currentPoints,
                  //   parsedStat
                  // );

                  const hasPercent = value.includes("%");
                  const numberMatch = value.match(/[-+]?\d*\.?\d+/);
                  const val = numberMatch ? parseFloat(parsedStat) : 0;

                  totals[name] = totals[name] || { total: 0, color, isPercent: hasPercent };
                  totals[name].total += val;
                });
              }
              return totals;
            }, {});
          },
          showStatValue() {
            this.calculateTotalStats();
          },
          parseStatValue(value, currentPoints) {
            // Ensure that value is a non-null string.
            if (typeof value !== "string") {
              throw new TypeError("The value must be a string.");
            }

            // Trim the input value to remove extra whitespace.
            value = value.trim();

            value = value.replace(/SpentTreePoints/g, this.totalPointsSpent);
            value = value.replace(/TreeMaxPoints/g, this.maxPoints);

            // Regex for detecting a bracket expression with optional trailing text.
            const bracketRegex = /\[([^\]]+)\](.*)/;
            const bracketMatch = value.match(bracketRegex);

            if (bracketMatch) {
              let expression = bracketMatch[1].trim(); // Text inside the brackets.
              let suffix = bracketMatch[2] ? bracketMatch[2].trim() : ""; // Any trailing text.

              // --- Level-Based Mapping ---
              if (/^Level\b/i.test(expression)) {
                const levelMapping = {};
                // Capture level mappings like "Level 1: 10" or "Level 1: 1d4".
                const levelRegex = /Level\s*(\d+):\s*([^,]+)/gi;
                let m;
                while ((m = levelRegex.exec(expression)) !== null) {
                  const level = parseInt(m[1], 10);
                  const val = m[2].trim();
                  levelMapping[level] = val;
                }

                // Use currentPoints as a level indicator.
                let selectedValue = levelMapping[currentPoints];
                if (selectedValue === undefined) {
                  // Fallback: choose the highest defined level less than or equal to currentPoints.
                  const levels = Object.keys(levelMapping)
                    .map(Number)
                    .sort((a, b) => a - b);
                  for (let i = levels.length - 1; i >= 0; i--) {
                    if (currentPoints >= levels[i]) {
                      selectedValue = levelMapping[levels[i]];
                      break;
                    }
                  }
                }
                return selectedValue ? selectedValue + (suffix ? " " + suffix : "") : null;
              }

              // --- Per Point Scaling / Arithmetic Expression ---
              // Validate allowed characters: digits, spaces, arithmetic symbols, parentheses, dot, %, and "CurrentPoints".
              // make sure this is only in the [ ] section
              // if (!/^[\d\s\+\-\*\/\.\%\(\)CurrentPoints]+$/i.test(expression)) {
              //   throw new Error("Invalid characters in the arithmetic expression.");
              // }

              // Convert percentages to decimals (e.g. "5%" => "0.05").
              expression = expression.replace(/(\d+)%/g, (_, p1) => {
                return (parseFloat(p1) / 100).toString();
              });

              // Replace all occurrences of "CurrentPoints" with the provided currentPoints.
              expression = expression.replace(/CurrentPoints/g, currentPoints);

              expression = expression.replace(/\^/g, "**");
              expression = expression
                .replace(/round\(/g, "Math.round(")
                .replace(/floor\(/g, "Math.floor(")
                .replace(/ceil\(/g, "Math.ceil(");

              let result;
              try {
                // Evaluate the arithmetic expression.
                result = new Function("return " + expression)();
              } catch (error) {
                // console.error("Error evaluating expression:", expression, error);
                // throw new Error("Error evaluating expression: " + expression);
                return 0;
              }

              return result + (suffix ? " " + suffix : "");
            } else if (value.includes("CurrentPoints")) {
              // --- No Brackets but Contains "CurrentPoints" ---
              // Use a regex to capture an arithmetic expression possibly followed by text.
              // This regex splits the string into an arithmetic part and an optional suffix.
              const nonBracketRegex = /^([\d\s\+\-\*\/\.\%\(\)\^CurrentPoints]+)(.*)$/i;
              const nonBracketMatch = value.match(nonBracketRegex);

              if (nonBracketMatch) {
                let expression = nonBracketMatch[1].trim();
                let suffix = nonBracketMatch[2] ? nonBracketMatch[2].trim() : "";

                // Validate allowed characters (the same basic check as for the bracketed case).
                if (!/^[\d\s\+\-\*\/\.\%\(\)CurrentPoints]+$/i.test(expression)) {
                  throw new Error("Invalid characters in the arithmetic expression.");
                }

                // Convert percentage values to decimals.
                expression = expression.replace(/(\d+)%/g, (_, p1) => {
                  return (parseFloat(p1) / 100).toString();
                });

                // Replace "CurrentPoints" with the actual value.
                expression = expression.replace(/CurrentPoints/g, currentPoints);

                expression = expression.replace(/\^/g, "**");
                expression = expression
                  .replace(/round\(/g, "Math.round(")
                  .replace(/floor\(/g, "Math.floor(")
                  .replace(/ceil\(/g, "Math.ceil(");

                let result;
                try {
                  result = new Function("return " + expression)();
                } catch (error) {
                  // console.error("Error evaluating expression:", expression, error);
                  // throw new Error("Error evaluating expression: " + expression);
                  return 0;
                }

                return result + (suffix ? " " + suffix : "");
              } else {
                throw new Error("Expression containing 'CurrentPoints' is in an invalid format.");
              }
            } else {
              // --- Basic Stat Value Handling ---
              // Process basic values. If the value ends with a percent, return the string;
              // if numeric, return it as a number.
              if (value.endsWith("%")) {
                return value;
              } else if (!isNaN(value)) {
                return parseFloat(value);
              } else {
                return value;
              }
            }
          },

          // parseStatValue(value, currentPoints) {
          //   if (!value) return "0";

          //   // Handle expressions with CurrentPoints
          //   if (value.includes("[") && !value.includes("Level")) {
          //     const match = value.match(/\[(.*?)\]/);
          //     if (match) {
          //       const expression = match[1].replace("CurrentPoints", currentPoints);
          //       try {
          //         const result = eval(expression);
          //         return Number.isInteger(result) ? result.toString() : result.toFixed(1);
          //       } catch (e) {
          //         return value;
          //       }
          //     }
          //   } else {
          //     // Handle level-based values
          //     const levelMatch = value.match(/Level \d+: ([^,\]]+)/);
          //     if (levelMatch) {
          //       return levelMatch[1].trim();
          //     }
          //   }

          //   // Handle basic numbers with optional percentage
          //   // const numberMatch = value.match(/[-+]?\d*\.?\d+/);
          //   // if (numberMatch) {
          //   //   const number = parseFloat(numberMatch[0]);
          //   //   return value.includes("%") ? `${number}%` : number.toString();
          //   // }

          //   console.log("parsing stat value", value, currentPoints);

          //   return value;
          // },
          handleResourceRowMouseDown(event) {
            // Only allow drag if we're not clicking on an input
            if (!event.target.matches("input")) {
              event.target.closest(".edit-resource-row").draggable = true;
            } else {
              event.target.closest(".edit-resource-row").draggable = false;
            }
          },
          exportToDataTable() {
            // Deselect all skills for clean export
            this.deselectAllSkills();

            // Define CSV headers that match a typical Unreal Engine struct
            // These should match exactly what you'd define in your UStruct
            const headers = [
              "SkillName", // FName - Primary key for the data table
              "DisplayName", // FText - User-friendly name
              "Description", // FText - Skill description
              "MaxRank", // int32 - Maximum skill rank
              "InitialRank", // int32 - Starting rank
              "RequiredPoints", // int32 - Points needed in tree to unlock
              "SkillIcon", // FSoftObjectPath - Path to icon texture
              "Prerequisites", // FString - Semicolon separated list of required skill names
              "Cost", // int32 - Cost to acquire
              "Cooldown", // float - Base cooldown in seconds
              "ManaCost", // float - Base mana cost
              "DamageValue", // float - Base damage value
              "DamageType", // FString - Type of damage (Physical, Magic, etc.)
              "EffectTags", // FString - Semicolon separated gameplay tags
              "StatRequirements", // FString - Required stats in format "StatName:Value;StatName:Value"
              "AbilityClass", // FSoftClassPath - Reference to the gameplay ability class
              "RowName", // FName - Unique identifier (same as SkillName, required for import)
            ].join(",");

            // Convert skills to CSV rows
            const rows = this.skills.map((skill) => {
              // Get prerequisites
              const prerequisites = this.connections
                .filter((conn) => conn.to === skill.id)
                .map((conn) => {
                  const prereqSkill = this.skills.find((s) => s.id === conn.from);
                  return prereqSkill ? prereqSkill.name : "";
                })
                .join(";");

              // Parse resources for common attributes
              let damageValue = "0.0";
              let damageType = "None";
              let manaCost = "0.0";
              let cooldown = "0.0";
              let effectTags = [];

              if (skill.resources) {
                skill.resources.forEach((resource) => {
                  const name = resource.name.toLowerCase();
                  const value = this.parseEffectValue(resource.value, skill.currentPoints);

                  if (name.includes("damage")) {
                    damageValue = value;
                    damageType = name.includes("magic")
                      ? "Magic"
                      : name.includes("physical")
                      ? "Physical"
                      : "Generic";
                  }
                  if (name.includes("mana")) manaCost = value;
                  if (name.includes("cooldown")) cooldown = value;

                  // Convert resource to gameplay tag
                  effectTags.push(`Ability.Effect.${resource.name.replace(/\s+/g, "")}`);
                });
              }

              // Create the row with proper escaping for CSV
              const rowData = [
                skill.name.replace(/\s+/g, ""), // SkillName (no spaces for FName)
                skill.name, // DisplayName
                (skill.description || "").replace(/"/g, '""'), // Description
                skill.maxPoints, // MaxRank
                skill.currentPoints, // InitialRank
                skill.requiredPoints || 0, // RequiredPoints
                skill.image.includes("data:") // SkillIcon
                  ? "/Game/Icons/DefaultAbility"
                  : `/Game/Icons/${skill.image.split("/").pop().replace(".png", "")}`,
                prerequisites, // Prerequisites
                "1", // Cost
                cooldown, // Cooldown
                manaCost, // ManaCost
                damageValue, // DamageValue
                damageType, // DamageType
                effectTags.join(";"), // EffectTags
                "", // StatRequirements
                `/Game/Abilities/GA_${skill.name.replace(/\s+/g, "")}`, // AbilityClass
                skill.name.replace(/\s+/g, ""), // RowName
              ].map((value) => {
                // Wrap values in quotes if they contain commas or quotes
                if (typeof value === "string" && (value.includes(",") || value.includes('"'))) {
                  return `"${value}"`;
                }
                return value;
              });

              return rowData.join(",");
            });

            // Add a comment line explaining the struct needed
            const structComment = [
              "// To import this CSV, create a Data Table with a struct containing these fields:",
              "// SkillName (FName), DisplayName (FText), Description (FText), MaxRank (int32),",
              "// InitialRank (int32), RequiredPoints (int32), SkillIcon (FSoftObjectPath),",
              "// Prerequisites (FString), Cost (int32), Cooldown (float), ManaCost (float),",
              "// DamageValue (float), DamageType (FString), EffectTags (FString),",
              "// StatRequirements (FString), AbilityClass (FSoftClassPath), RowName (FName)",
            ].join("\n");

            // Combine comment, headers and rows
            const csv = [structComment, headers, ...rows].join("\n");

            // Create and trigger download
            const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.setAttribute("download", `Unreal Engine Data Table.csv`);
            link.click();
            URL.revokeObjectURL(link.href);
          },
          exportToGAS() {
            // Deselect all skills for clean export
            this.deselectAllSkills();

            const gasData = {
              AbilitySet: {
                Name: this.currentName.replace(/\s+/g, "_"),
                Description: this.currentClassDescription || "Generated Ability Set",
                Abilities: this.skills.map((skill) => ({
                  AbilityName: skill.name.replace(/\s+/g, "_"),
                  AbilityClass: "GameplayAbility",
                  AbilityLevel: skill.currentPoints,
                  MaxLevel: skill.maxPoints,
                  Prerequisites: this.connections
                    .filter((conn) => conn.to === skill.id)
                    .map((conn) => {
                      const prereqSkill = this.skills.find((s) => s.id === conn.from);
                      return prereqSkill ? prereqSkill.name.replace(/\s+/g, "_") : null;
                    })
                    .filter((name) => name !== null),
                  Effects: skill.resources
                    ? skill.resources.map((resource) => ({
                        EffectName: `GE_${skill.name.replace(/\s+/g, "_")}_${resource.name.replace(
                          /\s+/g,
                          "_"
                        )}`,
                        EffectType: this.determineEffectType(resource),
                        Magnitude: this.parseEffectValue(resource.value, skill.currentPoints),
                        Duration: this.isDurationEffect(resource)
                          ? this.parseDuration(resource.value)
                          : -1, // -1 for infinite
                        ModifierType: this.determineModifierType(resource),
                      }))
                    : [],
                  Tags: [
                    `Ability.${this.currentName.replace(/\s+/g, "_")}.${skill.name.replace(
                      /\s+/g,
                      "_"
                    )}`,
                  ],
                  RequiredPoints: skill.requiredPoints || 0,
                  IconPath: skill.image.includes("data:")
                    ? "Default Ability Icon"
                    : skill.image.split("/").pop(),
                })),
              },
            };

            // Create and trigger download
            const dataStr = JSON.stringify(gasData, null, 2);
            const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);
            const exportFileDefaultName = `Unreal Gameplay Ability System.json`;

            const linkElement = document.createElement("a");
            linkElement.setAttribute("href", dataUri);
            linkElement.setAttribute("download", exportFileDefaultName);
            linkElement.click();
          },

          // Helper methods for GAS export
          determineEffectType(resource) {
            const name = resource.name.toLowerCase();
            if (name.includes("damage")) return "Instant";
            if (name.includes("buff") || name.includes("boost")) return "Duration";
            if (name.includes("cooldown")) return "Cooldown";
            return "Infinite";
          },

          parseEffectValue(value, currentPoints) {
            try {
              // Handle percentage values
              if (typeof value === "string" && value.includes("%")) {
                return parseFloat(value) / 100;
              }
              // Handle numeric values
              const numValue = parseFloat(value);
              return isNaN(numValue) ? 1.0 : numValue;
            } catch (e) {
              return 1.0;
            }
          },

          isDurationEffect(resource) {
            const name = resource.name.toLowerCase();
            return (
              name.includes("duration") ||
              name.includes("buff") ||
              name.includes("boost") ||
              name.includes("temporary")
            );
          },

          parseDuration(value) {
            // Default duration in seconds
            try {
              const numValue = parseFloat(value);
              return isNaN(numValue) ? 5.0 : numValue;
            } catch (e) {
              return 5.0;
            }
          },

          determineModifierType(resource) {
            const name = resource.name.toLowerCase();
            const value = resource.value.toString().toLowerCase();

            if (value.includes("%") || name.includes("multiplier") || name.includes("percent")) {
              return "Multiplicative";
            }
            return "Additive";
          },
          handleUrlUpload() {
            if (!this.imageUrl) {
              const urlInput = document.querySelector(".url-input");
              if (urlInput) {
                urlInput.focus();
              }
              return;
            }

            const newImage = {
              id: "custom-" + Date.now(),
              src: this.imageUrl,
              name: this.imageUrl.split("/").pop() || "URL Image",
              isDefault: false,
            };

            this.customImages.push(newImage);
            localStorage.setItem("customImages", JSON.stringify(this.customImages));
            this.selectImage(newImage);
            this.imageUrl = ""; // Clear the input
          },
          openDefaultImageSelector() {
            this.showImageSelector = true;
            this.selectingDefaultImage = true;
            // // Preselect the current default
            // const currentImage = this.allImages.find(img => img.src === this.defaultSkillImage);
            // this.selectedImage = currentImage ? currentImage.id : null;
          },

          autoFormatCircle() {
            // First, identify root nodes (skills with no prerequisites)
            const rootNodes = this.skills.filter((skill) => {
              return !this.connections.some((conn) => conn.to === skill.id);
            });

            // Calculate center of the viewport
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            // Place root nodes in a circle at the center
            const rootRadius = 150; // Radius for root nodes circle
            rootNodes.forEach((rootNode, index) => {
              const angle = (index / rootNodes.length) * 2 * Math.PI;
              rootNode.x = centerX + rootRadius * Math.cos(angle);
              rootNode.y = centerY + rootRadius * Math.sin(angle);
            });

            // Helper function to get all direct children of a node
            const getChildren = (nodeId) => {
              return this.connections
                .filter((conn) => conn.from === nodeId)
                .map((conn) => this.skills.find((s) => s.id === conn.to));
            };

            // Helper function to get the level of a node (distance from root)
            const getNodeLevel = (nodeId, visited = new Set()) => {
              if (visited.has(nodeId)) return 0;
              visited.add(nodeId);

              const parentConns = this.connections.filter((conn) => conn.to === nodeId);
              if (parentConns.length === 0) return 0;

              return (
                1 +
                Math.max(...parentConns.map((conn) => getNodeLevel(conn.from, new Set(visited))))
              );
            };

            // Process each root node's branches
            rootNodes.forEach((rootNode, rootIndex) => {
              const processNode = (node, level, parentAngle, spreadAngle) => {
                const children = getChildren(node.id);
                if (children.length === 0) return;

                const radius = rootRadius + level * 150; // Increase radius for each level
                const angleStep = spreadAngle / children.length;
                const startAngle = parentAngle - spreadAngle / 2;

                children.forEach((child, index) => {
                  const childAngle = startAngle + angleStep * (index + 0.5);
                  child.x = centerX + radius * Math.cos(childAngle);
                  child.y = centerY + radius * Math.sin(childAngle);

                  // Calculate spread angle for next level based on available space
                  const nextSpreadAngle = angleStep * 0.8; // Slightly reduce spread for next level
                  processNode(child, level + 1, childAngle, nextSpreadAngle);
                });
              };

              // Calculate initial spread angle for this root node's branch
              const spreadAngle = (2 * Math.PI) / rootNodes.length;
              const rootAngle = (rootIndex / rootNodes.length) * 2 * Math.PI;
              processNode(rootNode, 1, rootAngle, spreadAngle);
            });

            // Snap all positions to grid if grid snap is enabled
            if (this.gridSnapEnabled) {
              this.skills.forEach((skill) => {
                const snapped = this.snapToGrid(skill.x, skill.y, skill.size);
                skill.x = snapped.x;
                skill.y = snapped.y;
              });
            }

            this.handleResize();
            // Save the new layout to history
            this.saveToHistory();
          },

          removeImage(image) {
            // Remove from customImages
            this.customImages = this.customImages.filter((img) => img.id !== image.id);
            localStorage.setItem("customImages", JSON.stringify(this.customImages));
            // Deselect if it was selected

            if (this.selectedImage === image.id) {
              const defaultImageObj = this.allImages.find((img) => img.isDefault);
              this.selectedImage = defaultImageObj ? defaultImageObj.id : null;
              // this.selectedImage = null;
              if (this.editingSkill) {
                this.editingSkill.image = defaultImageObj ? defaultImageObj.src : "";
              }
            }
          },
          getUnmetRequirements(skill) {
            const requirements = [];

            // Check mutual exclusivity
            if (skill.exclusiveSkillIds && skill.exclusiveSkillIds.length > 0) {
              const activeExclusiveSkills = skill.exclusiveSkillIds
                .filter((exclusiveId) => {
                  const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                  return exclusiveSkill && exclusiveSkill.currentPoints > 0;
                })
                .map((exclusiveId) => {
                  const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                  return exclusiveSkill.name;
                });

              if (activeExclusiveSkills.length > 0) {
                requirements.push(`Conflicts with: ${activeExclusiveSkills.join(", ")}`);
              } else {
                // Show which skills are mutually exclusive (even if not active)
                const exclusiveSkillNames = skill.exclusiveSkillIds
                  .map((exclusiveId) => {
                    const exclusiveSkill = this.skills.find((s) => s.id === exclusiveId);
                    return exclusiveSkill?.name || "Unknown";
                  })
                  .filter((name) => name !== "Unknown");

                if (exclusiveSkillNames.length > 0) {
                  requirements.push(`Mutually exclusive with: ${exclusiveSkillNames.join(", ")}`);
                }
              }
            }

            // Check if we have enough total points spent
            if (skill.requiredPoints && this.totalPointsSpent < skill.requiredPoints) {
              requirements.push(
                `${skill.requiredPoints} total points needed (Current: ${this.totalPointsSpent})`
              );
            }

            // Check if skill has required points using legacy damage field
            if (skill.damage) {
              const requiredPoints = parseInt(skill.damage);
              if (!isNaN(requiredPoints) && this.totalPointsSpent < requiredPoints) {
                requirements.push(
                  `${requiredPoints} total points needed (Current: ${this.totalPointsSpent})`
                );
              }
            }

            // Check prerequisite skills
            const incomingConnections = this.connections.filter((conn) => conn.to === skill.id);
            if (incomingConnections.length > 0 && this.prerequisiteMode !== "none") {
              if (this.prerequisiteMode === "all") {
                // Check if ALL prerequisite skills are unlocked
                const missingPrereqs = incomingConnections
                  .filter((conn) => {
                    const prereqSkill = this.skills.find((s) => s.id === conn.from);
                    return !prereqSkill || prereqSkill.currentPoints === 0;
                  })
                  .map((conn) => {
                    const prereqSkill = this.skills.find((s) => s.id === conn.from);
                    return prereqSkill?.name || "Unknown";
                  });

                if (missingPrereqs.length > 0) {
                  requirements.push(`Requires: ${missingPrereqs.join(", ")}`);
                }
              } else {
                // 'one' mode - check if at least one prerequisite skill is unlocked
                const hasUnlockedPrereq = incomingConnections.some((conn) => {
                  const prereqSkill = this.skills.find((s) => s.id === conn.from);
                  return prereqSkill && prereqSkill.currentPoints > 0;
                });

                if (!hasUnlockedPrereq) {
                  const prereqNames = incomingConnections.map((conn) => {
                    const prereqSkill = this.skills.find((s) => s.id === conn.from);
                    return prereqSkill?.name || "Unknown";
                  });
                  requirements.push(`Requires one of: ${prereqNames.join(" or ")}`);
                }
              }
            }

            return requirements;
          },
          calculateMidpoint(fromSkill, toSkill) {
            const fromCenterX = fromSkill.x + fromSkill.size / 2;
            const fromCenterY = fromSkill.y + fromSkill.size / 2;
            const toCenterX = toSkill.x + toSkill.size / 2;
            const toCenterY = toSkill.y + toSkill.size / 2;

            return {
              x: (fromCenterX + toCenterX) / 2,
              y: (fromCenterY + toCenterY) / 2,
            };
          },
          splitSkill(skill) {
            // Hide actions for the original skill
            skill.showActions = false;

            // Calculate positions for the two new skills
            const offsetDistance = this.gridSize / 2; // Distance between split skills
            const skill1X = skill.x - offsetDistance;
            const skill2X = skill.x + offsetDistance;

            // Create first skill (left)
            const skill1 = {
              id: ++this.skillIdCounter,
              name: `${skill.name} Option A`,
              description: skill.description,
              x: skill1X,
              y: skill.y,
              showActions: false,
              showTooltip: false,
              maxPoints: skill.maxPoints,
              currentPoints: 0,
              requiredPoints: skill.requiredPoints || 0,
              image: skill.image,
              shouldAnimate: true,
              resources: [...(skill.resources || [])],
              size: skill.size,
              borderType: skill.borderType,
              shape: skill.shape,
              cost: skill.cost,
              prerequisiteModeOverride: skill.prerequisiteModeOverride,
              exclusiveSkillIds: [], // Will be set after creating skill2
            };

            // Create second skill (right)
            const skill2 = {
              id: ++this.skillIdCounter,
              name: `${skill.name} Option B`,
              description: skill.description,
              x: skill2X,
              y: skill.y,
              showActions: false,
              showTooltip: false,
              maxPoints: skill.maxPoints,
              currentPoints: 0,
              requiredPoints: skill.requiredPoints || 0,
              image: skill.image,
              shouldAnimate: true,
              resources: [...(skill.resources || [])],
              size: skill.size,
              borderType: skill.borderType,
              shape: skill.shape,
              cost: skill.cost,
              prerequisiteModeOverride: skill.prerequisiteModeOverride,
              exclusiveSkillIds: [], // Will be set after creating skill1
            };

            // Set mutual exclusivity between the two skills
            skill1.exclusiveSkillIds = [skill2.id];
            skill2.exclusiveSkillIds = [skill1.id];

            // Snap to grid if enabled
            if (this.showGlobalGrid) {
              const snappedPos1 = this.snapToGrid(skill1.x, skill1.y, skill1.size);
              const snappedPos2 = this.snapToGrid(skill2.x, skill2.y, skill2.size);
              skill1.x = snappedPos1.x;
              skill1.y = snappedPos1.y;
              skill2.x = snappedPos2.x;
              skill2.y = snappedPos2.y;
            }

            // Update connections that pointed to the original skill
            this.connections.forEach((connection) => {
              if (connection.to === skill.id) {
                // Create connections to both new skills
                this.connections.push({
                  id: `${connection.from}-${skill1.id}`,
                  from: connection.from,
                  to: skill1.id,
                  hasControlPoint: connection.hasControlPoint,
                  controlPoint: this.calculateMidpoint(
                    this.skills.find((s) => s.id === connection.from),
                    skill1
                  ),
                  mutuallyExclusive: false,
                  dotted: false,
                });

                this.connections.push({
                  id: `${connection.from}-${skill2.id}`,
                  from: connection.from,
                  to: skill2.id,
                  hasControlPoint: connection.hasControlPoint,
                  controlPoint: this.calculateMidpoint(
                    this.skills.find((s) => s.id === connection.from),
                    skill2
                  ),
                  mutuallyExclusive: false,
                  dotted: false,
                });
              }

              if (connection.from === skill.id) {
                // Update connections from the original skill
                // Create connections from both new skills to the target
                this.connections.push({
                  id: `${skill1.id}-${connection.to}`,
                  from: skill1.id,
                  to: connection.to,
                  hasControlPoint: connection.hasControlPoint,
                  controlPoint: this.calculateMidpoint(
                    skill1,
                    this.skills.find((s) => s.id === connection.to)
                  ),
                  mutuallyExclusive: false,
                  dotted: false,
                });

                this.connections.push({
                  id: `${skill2.id}-${connection.to}`,
                  from: skill2.id,
                  to: connection.to,
                  hasControlPoint: connection.hasControlPoint,
                  controlPoint: this.calculateMidpoint(
                    skill2,
                    this.skills.find((s) => s.id === connection.to)
                  ),
                  mutuallyExclusive: false,
                  dotted: false,
                });
              }
            });

            // Remove the original skill and its connections
            this.skills = this.skills.filter((s) => s.id !== skill.id);
            this.connections = this.connections.filter(
              (c) => c.from !== skill.id && c.to !== skill.id
            );

            // Add the two new skills
            this.skills.push(skill1, skill2);

            // Save to history
            this.saveToHistory();

            // Force animation to show
            this.$nextTick(() => {
              const skill1Element = document.querySelector(`[data-skill-id="${skill1.id}"] img`);
              const skill2Element = document.querySelector(`[data-skill-id="${skill2.id}"] img`);
              if (skill1Element) skill1Element.style.opacity = "1";
              if (skill2Element) skill2Element.style.opacity = "1";
            });
          },
          calculateMidpoint(fromSkill, toSkill) {
            const fromCenterX = fromSkill.x + fromSkill.size / 2;
            const fromCenterY = fromSkill.y + fromSkill.size / 2;
            const toCenterX = toSkill.x + toSkill.size / 2;
            const toCenterY = toSkill.y + toSkill.size / 2;

            return {
              x: (fromCenterX + toCenterX) / 2,
              y: (fromCenterY + toCenterY) / 2,
            };
          },
          skillMouseEnter(skill) {
            if (!this.keepTooltipOpen) {
              skill.showTooltip = true;
            } else {
              skill.showTooltip = true;
              // only close the old tooltip if it's not the same skill
              if (this.hoveredSkill && this.hoveredSkill.id !== skill.id) {
                this.hoveredSkill.showTooltip = false;
              }
              this.hoveredSkill = skill;
            }
          },
          skillMouseLeave(skill) {
            if (!this.keepTooltipOpen) {
              skill.showTooltip = false;
            }
          },
        },
      }).mount("#app");
    </script>
  </body>
</html>
